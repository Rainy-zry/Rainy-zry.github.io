<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RustDay13 Vec &amp; Hashmap</title>
    <url>/2024/09/05/Rust-Day13/</url>
    <content><![CDATA[<h2 id="1、Vector-Heap-Dynamic"><a href="#1、Vector-Heap-Dynamic" class="headerlink" title="1、Vector - Heap, Dynamic"></a>1、Vector - Heap, Dynamic</h2><ul>
<li>Set up:  <code>Vec::new();</code>  <code>vec![1,2,3];</code></li>
<li>Add: <code>v.push(10)</code></li>
<li>Read: <ul>
<li><code>vv = &amp;v[index]</code> if null – panic   </li>
<li><code>v.get(index)</code> return <code>Option&lt;&amp;T&gt;</code></li>
<li><code>v.get_unchecked(2)</code> return <code>&amp;i32</code> <code>unsafe</code></li>
</ul>
</li>
<li><strong>Go through</strong> <ul>
<li><code>for vv in v</code>  </li>
<li><code>for vv in &amp;v</code>  </li>
<li><code>for vv in &amp;mut v</code></li>
<li><code>for vv:&amp;132 in v.iter()</code>  <code>for vv:&amp;mut i32 in v.iter_mut()</code></li>
<li>Consume v:<ul>
<li>&#96;let consume_v &#x3D; v.into_iter(); </li>
<li><code>for vv in consume_v&#123;&#125;;</code>  v has been consumed, cannot be used</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![1, 2, 3];</span><br><span class="line">    let iter = v.into_iter();</span><br><span class="line">    for x in iter &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, x); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Delete: <ul>
<li><code>v.pop()</code> return <code>Option&lt;T&gt;</code>  </li>
<li><code>v.remove(index)</code> return <code>T</code></li>
</ul>
</li>
<li>Append&#x2F;Spilt&#x2F;Insert <ul>
<li><code>v1.append(&amp;mut v2)</code>  </li>
<li><code>v1 = v.split_off(3)</code> 2|3  </li>
<li><code>v.insert(index,val)</code></li>
</ul>
</li>
<li>Copy slice: <code>let v1 = v.clone()</code>  <code>v.copy_from_slice(&amp;slice);</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = vec![10, 20, 30, 40, 50];</span><br><span class="line">    let val = &amp;v[2];</span><br><span class="line">    println!(&quot;The third element is &#123;&#125;&quot;, val); </span><br><span class="line">    if let Some(x) = v.get(2)&#123;</span><br><span class="line">	    println!(&quot;&#123;&#125;&quot;,x);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">		println!(&quot;none&quot;);  </span><br><span class="line">    &#125;</span><br><span class="line">	let a: Option&lt;i32&gt; = v.pop();</span><br><span class="line">	let b: i32 = v.remove(1);</span><br><span class="line"></span><br><span class="line">	let mut v2 = vec![100,1000,10000];</span><br><span class="line">	v.append(&amp; mut v2);</span><br><span class="line">	v1 = v.split_off(3);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>filter and map</strong>  <ul>
<li><code>v.iter().filter(|&amp;&amp;x| condition).collect()</code></li>
<li><code>v.iter().map(|x| f(x) ).collect()</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![1, 2, 3, 4, 5];</span><br><span class="line">    let evens: Vec&lt;_&gt; = v.iter().filter(|&amp;&amp;x| x % 2 == 0).collect();</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, evens); </span><br><span class="line">    </span><br><span class="line">    let doubled: Vec&lt;_&gt; = v.iter().map(|x| x * 2).collect();</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, doubled); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>vec -&gt; array<ul>
<li><code>b:Box&lt;[i32]&gt; = v.into_boxed_slice()</code></li>
<li><code>a: Box&lt;[i32;n]&gt; = a.try_into().unwrap()</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![1, 2, 3];</span><br><span class="line">    </span><br><span class="line">    let boxed_slice = v.into_boxed_slice();</span><br><span class="line">    let array: Box&lt;[i32; 3]&gt; = boxed_slice.try_into().unwrap();</span><br><span class="line">    </span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, array); // 输出: [1, 2, 3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>vec+ enum</strong><br>Set up:<br><code>let t: Vec&lt;Enumname&gt; = vec![Test::V1,Test::V2]</code><br>Go through:<br><code>for (a,b:&amp;Enumname) in t.iter().enumerate()&#123;&#125; </code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum Test &#123;</span><br><span class="line">        Integer(i32),</span><br><span class="line">        Float(f64),</span><br><span class="line">        Text(String),</span><br><span class="line">    &#125;</span><br><span class="line">    let t: Vec&lt;Test&gt; = vec![</span><br><span class="line">        Test::Integer(42),</span><br><span class="line">        Test::Float(3.14),</span><br><span class="line">        Test::Text(String::from(&quot;Hello&quot;)),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    for (index:usize, tt: &amp;Test) in t.iter().enumerate() &#123;</span><br><span class="line">        match item &#123;</span><br><span class="line">            Test::Integer(value) =&gt; println!(&quot;Index &#123;&#125;: Integer(&#123;&#125;)&quot;, index, value),</span><br><span class="line">            Test::Float(value) =&gt; println!(&quot;Index &#123;&#125;: Float(&#123;&#125;)&quot;, index, value),</span><br><span class="line">            Test::Text(value) =&gt; println!(&quot;Index &#123;&#125;: Text(&#123;&#125;)&quot;, index, value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Capacity and reset</strong><br><strong>When capacity needs to extend, Double it</strong><ul>
<li>Initially allocate: <code>Vec::with_capacity(n)</code></li>
<li>Check: <code>v.capacity()</code></li>
<li>Adjust: <code>v.shrink_to_fit();</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut vec = Vec::with_capacity(2); </span><br><span class="line"></span><br><span class="line">    println!(&quot;Initial capacity: &#123;&#125;&quot;, vec.capacity());</span><br><span class="line"></span><br><span class="line">    vec.push(1);</span><br><span class="line">    vec.push(2);</span><br><span class="line">// 2 </span><br><span class="line">    println!(&quot;Capacity after pushing 2 elements: &#123;&#125;&quot;, vec.capacity());</span><br><span class="line"></span><br><span class="line">    vec.push(3); // Re-allocate</span><br><span class="line">// 4</span><br><span class="line">    println!(&quot;Capacity after pushing 3rd element: &#123;&#125;&quot;, vec.capacity());</span><br><span class="line">    vec.shrink_to_fit();</span><br><span class="line">    println!(&quot;Capacity after shrink: &#123;&#125;&quot;, vec.capacity());</span><br><span class="line">// 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2、HashMap"><a href="#2、HashMap" class="headerlink" title="2、HashMap"></a>2、HashMap</h2><p><code>use std::collections::HashMap;</code></p>
<ul>
<li>Set up:<ul>
<li>Blank: <code>let h:HashMap&lt;String,i32&gt; = HashMap::new()</code></li>
<li>Initialization: <code>let mut h = HashMap::from([(String::from(&quot;A&quot;):1),(..)])</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut map: HashMap&lt;String, i32&gt; = HashMap::new();</span><br><span class="line">    map.insert(String::from(&quot;A&quot;),3);</span><br><span class="line">    </span><br><span class="line">    let mut scores = HashMap::from([</span><br><span class="line">        (String::from(&quot;Blue&quot;), 10),</span><br><span class="line">        (String::from(&quot;Yellow&quot;), 50),</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, map);   </span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, scores); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Insert and update  <ul>
<li><code>a.insert(String::from(&quot;A&quot;),10)</code></li>
<li><code>a.insert(String::from(&quot;A&quot;),30)</code> Updated</li>
</ul>
</li>
<li>Combine:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (key, value) in a2&#123;</span><br><span class="line">	a1.entry(key).or_insert(value); // No cover</span><br><span class="line">	//a1.entry(key).insert(value);// cover</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
<li>Read: <ul>
<li><code>a.get(&quot;A&quot;)</code> return <code>Option&lt;&amp;T&gt;</code>  <code>if le some(v) = a.get_mut(&quot;A&quot;)&#123;*v=3&#125; </code></li>
<li><code>let keys: Vec&lt;_&gt; = a.keys().collect();</code> </li>
<li><code>let values: Vec&lt;_&gt; = a.values().collect();</code></li>
</ul>
</li>
<li>Delete: <ul>
<li><code>a.remove(&quot;A&quot;)</code> return <code>Option&lt;T&gt;</code></li>
<li><code>a.clear()</code></li>
</ul>
</li>
<li>if certain key exist: <code>if a.contains_key(&quot;A&quot;)</code></li>
<li>Go through: <ul>
<li><code>for (key: &amp;String,val: &amp;i32) in &amp;mut a &#123;*val = 0;&#125;</code></li>
<li><strong>Key are unchangeable</strong></li>
<li><ul>
<li><code>match</code>  <ul>
<li><code>match key.as_str()&#123;&quot;A&quot; =&gt;&#123;&#125;&#125;</code></li>
<li><code>match value&#123;0..=20 =&gt;&#123;&#125;&#125;</code></li>
<li><code>match (key.as_str(),value)&#123;(&quot;A&quot;,_) =&gt; &#123;&#125;&#125;</code></li>
<li>+if <code>match key.as_str()&#123;&quot;A&quot; if *value&lt;10 =&gt; &#123;&#125;&#125;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">    </span><br><span class="line">    scores.insert(String::from(&quot;Blue&quot;), 10);</span><br><span class="line">    scores.insert(String::from(&quot;Yellow&quot;), 50);</span><br><span class="line">    scores.insert(String::from(&quot;Red&quot;), 30);</span><br><span class="line">    </span><br><span class="line">    for (key: &amp;String, value:&amp;i32) in &amp;scores &#123;</span><br><span class="line">        match key.as_str() &#123;</span><br><span class="line">            &quot;Blue&quot; if *value &lt; 20 =&gt; println!(&quot;&#123;&#125; has a low score of &#123;&#125;&quot;, key, value),</span><br><span class="line">            &quot;Yellow&quot; if *value &gt;= 20 =&gt; println!(&quot;&#123;&#125; has a high score of &#123;&#125;&quot;, key, value),</span><br><span class="line">            _ =&gt; println!(&quot;&#123;&#125; has a score of &#123;&#125;&quot;, key, value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Hash Ownership</strong><br><strong>Lifetime of variants is determined by:  LAST TIME being Used &amp; Block Scope.</strong><ul>
<li>ISERT: <code>h.insert(k,v)</code>  k, v Ownership transferred</li>
<li>READ: <code>h.get()</code> and <code>h.get_mut()</code> <ul>
<li>can’t operate together in the same scope</li>
<li><code>get_mut()</code> can’t be used tewice</li>
</ul>
</li>
<li>FETCH: <code>let m1 = map.get(&quot;A&quot;)</code> <ul>
<li><code>if let Some(v:&amp;i32)=m1 &#123;&#125;</code>  m1 ownsership transferred</li>
<li>&#96;if let Some(v:&amp;&amp;i32)&#x3D;&amp;m1{} √</li>
</ul>
</li>
<li>TRANSFER: <ul>
<li><code>fn process(map: HashMap&lt;String,i32&gt;)&#123;&#125; process(map);</code> map ownership lost</li>
<li><code>fn process(map: &amp;HashMap&lt;String,i32&gt;)&#123;&#125; process(&amp;map);</code> √</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">	let mut map = HashMap::new();</span><br><span class="line">    map.insert(&quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">    </span><br><span class="line">    let m2 = map.get_mut(&quot;key1&quot;); //m2 start</span><br><span class="line">    if let Some(v) = m2&#123;</span><br><span class="line">        *v = &quot;new value1&quot;;</span><br><span class="line">    &#125; </span><br><span class="line">    //println!(&quot;&#123;:?&#125;&quot;,m2); // m2 lost ownership</span><br><span class="line">    //m2 ends</span><br><span class="line">    </span><br><span class="line">	let m1 = map.get(&quot;key1&quot;); //m1 starts</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,m1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、hash-collision"><a href="#3、hash-collision" class="headerlink" title="3、hash collision"></a>3、hash collision</h2><p>A Hash Collision is when <strong>two different keys</strong> are mapped to <strong>the same index</strong></p>
<h3 id="seperate-chaining"><a href="#seperate-chaining" class="headerlink" title="seperate chaining"></a>seperate chaining</h3><p>Set up a hashmap: every <code>Index</code> –&gt; store a <code>Vec&lt;(key,value)&gt;</code></p>
<ul>
<li><code>let mut a: HashMap&lt;u32, Vec&lt;u32,u32&gt;&gt; = HashMap::new();</code></li>
<li><code>h.entry(index).or_insert(Vec::new()).push((k,v))</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">fn hash(key: u32) -&gt; u32 &#123;</span><br><span class="line">    key % 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn insert(hash_table: &amp;mut HashMap&lt;u32, Vec&lt;(u32, u32)&gt;&gt;, key: u32, value: u32) &#123;</span><br><span class="line">    let index = hash(key); //function(key) --&gt; same index</span><br><span class="line">    hash_table.entry(index).or_insert(Vec::new()).push((key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn print_hash_table(hash_table: &amp;HashMap&lt;u32, Vec&lt;(u32, u32)&gt;&gt;) &#123;</span><br><span class="line">    for (index, list) in hash_table &#123;</span><br><span class="line">        println!(&quot;Index &#123;&#125;: &#123;:?&#125;&quot;, index, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut hash_table: HashMap&lt;u32, Vec&lt;(u32, u32)&gt;&gt; = HashMap::new();</span><br><span class="line"></span><br><span class="line">    insert(&amp;mut hash_table, 3, 9); //3%5=3</span><br><span class="line">    insert(&amp;mut hash_table, 8, 64); //8%5=3</span><br><span class="line">    insert(&amp;mut hash_table, 13, 169); //13%5=3</span><br><span class="line">    </span><br><span class="line">    print_hash_table(&amp;hash_table);</span><br><span class="line">&#125;</span><br><span class="line">//Index 3: [(3, 9), (8, 64), (13, 169)]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="linear-search"><a href="#linear-search" class="headerlink" title="linear search"></a>linear search</h3><p>Set up a hashmap <code>Vec&lt;&gt;</code>, every index –&gt; <code>Option&lt;(key,value)&gt;</code>  if full-index added, therefore, vector consists of <code>Some(k,v) and None</code></p>
<ul>
<li><code>let mut hash_table: Vec&lt;Option&lt;(u32,u32)&gt;&gt; = vec![None,5]</code></li>
<li><code>while h[index].is_some()&#123;change index&#125; h[index]=Some((k,v))</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn hash(key: u32) -&gt; usize &#123;</span><br><span class="line">	(key % 5) as usize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn insert(hash_table: &amp;mut Vec&lt;Option&lt;(u32, u32)&gt;&gt;, key: u32, value: u32) &#123;</span><br><span class="line">    let mut index = hash(key);</span><br><span class="line">    while hash_table[index].is_some() &#123;</span><br><span class="line">        index = (index + 1) % hash_table.len(); </span><br><span class="line">        // index 3 -&gt; (3+1)%1=4 -&gt; (3+1)%2=0</span><br><span class="line">    &#125;</span><br><span class="line">    hash_table[index] = Some((key, value));</span><br><span class="line">&#125;</span><br><span class="line">fn print_hash_table(hash_table: &amp;Vec&lt;Option&lt;(u32, u32)&gt;&gt;) &#123;</span><br><span class="line">    for (index:u32, pair: &amp;Option&lt;(u32,u32)&gt;) in hash_table.iter().enumerate() &#123;</span><br><span class="line">        match pair &#123;</span><br><span class="line">            Some((key, value)) =&gt; println!(&quot;Index &#123;&#125;: (&#123;&#125;, &#123;&#125;)&quot;, index, key, value),</span><br><span class="line">            None =&gt; println!(&quot;Index &#123;&#125;: Empty&quot;, index), // null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut hash_table = vec![None; 5];  </span><br><span class="line">    insert(&amp;mut hash_table, 3, 9);</span><br><span class="line">    insert(&amp;mut hash_table, 8, 64);</span><br><span class="line">    insert(&amp;mut hash_table, 13, 169);</span><br><span class="line">    print_hash_table(&amp;hash_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、zip"><a href="#4、zip" class="headerlink" title="4、zip()"></a>4、zip()</h2><ul>
<li>Combine two iters<br><code>for (a,b) in v1.iter().zip(v2.iter())</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v1 = vec![1, 2];</span><br><span class="line">    let v2 = vec![4, 5, 6];</span><br><span class="line"></span><br><span class="line">    for (a, b) in v1.iter().zip(v2.iter()) &#123;</span><br><span class="line">        println!(&quot;(&#123;&#125;, &#123;&#125;)&quot;, a, b); //(1,4) (2,5)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let v3 = vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line">     for (a, b) in v2.iter().zip(v3.iter()) &#123;</span><br><span class="line">        println!(&quot;(&#123;&#125;, &#123;&#125;)&quot;, a, b); //(4:a) (5:b) (6:c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>zip() + map&#x2F;filter<ul>
<li><code>v1.iter().zip(v2).map(|(a:&amp;i32,b:&amp;i32)|f(a,b)).collect()</code></li>
<li><code>v1.iter().zip(v2).filter(|(&amp;a:i32,&amp;b:i32)|condition).collect()</code></li>
</ul>
</li>
<li>zip() + enum<ul>
<li><code>for (i, (a, b)) in v1.iter().zip(v2.iter()).enumerate()</code> i 0..n</li>
</ul>
</li>
<li>unzip<br><code>let (vec1, vec2): (Vec&lt;_&gt;, Vec&lt;_&gt;) = v1.iter().zip(v2.iter()).unzip();</code></li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Vector</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay10 Rust data type—Enum</title>
    <url>/2024/08/26/Rust-Day10/</url>
    <content><![CDATA[<h2 id="1、Imply-Function"><a href="#1、Imply-Function" class="headerlink" title="1、Imply Function"></a>1、Imply Function</h2><h3 id="Associated-functions"><a href="#Associated-functions" class="headerlink" title="Associated functions"></a>Associated functions</h3><ul>
<li>Function parameters are customizable <code>asso_fun(s:&amp;str)</code></li>
<li>Function calling method <code>let val = Yiren::Feng_fun(1)</code></li>
<li>No need to consider <code>function-variant</code> relation<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Yiren&#123;</span><br><span class="line">	Fengbaobao(i32),</span><br><span class="line">	Zhangchulan(String),</span><br><span class="line">	Wangye&#123;x:String,y:String&#125;,</span><br><span class="line">&#125;</span><br><span class="line">impl Yiren&#123;</span><br><span class="line">	fn feng_fun(n:i32) -&gt; i32 &#123; </span><br><span class="line">		println!(&quot;冯宝宝&quot;);</span><br><span class="line">		n*n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">f main()&#123;</span><br><span class="line">	let val1 = Yiren::feng_fun(2); //print + return val</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,val1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Instance-method"><a href="#Instance-method" class="headerlink" title="Instance method"></a>Instance method</h3><ul>
<li>Input parameter: <code>self: &amp;self or &amp;mut self or self</code></li>
<li>Calling function <ul>
<li><code>let m1 = Yiren::Fengbaobao(2)  let val = m1.feng_fun()</code></li>
</ul>
</li>
<li>Ensure the <code>function-Variant</code> relation :<br>(1) <strong>Use <code>match</code></strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">impl Yiren&#123;</span><br><span class="line">	fn feng_fun( &amp;self ) -&gt; i32 &#123;</span><br><span class="line">		match self&#123;</span><br><span class="line">			Yiren::Fengbaobao(n) =&gt; &#123;</span><br><span class="line">				println!(&quot;冯宝宝&quot;);</span><br><span class="line">				n*n</span><br><span class="line">			&#125;</span><br><span class="line">			_ =&gt; &#123;</span><br><span class="line">				println!(&quot;Function only for Fengbaobao&quot;);</span><br><span class="line">				0</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">if let Yiren::Fengbaobao(n) = self &#123; n * n * n &#125; else &#123; panic!(&quot;This method is only applicable to Fengbaobao variant&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure>
(2) <strong>Use <code>if let</code></strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">impl Yiren&#123;</span><br><span class="line">	fn feng_fun( &amp;self ) -&gt; i32 &#123;</span><br><span class="line">		if let Yiren::Fengbaobao(n) = self &#123;</span><br><span class="line">			n*n</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			panic!(&quot;Function only for Fengbaobao&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
E.g.:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Yiren&#123;</span><br><span class="line">	Fengbaobao(i32),</span><br><span class="line">	Zhangchulan(String),</span><br><span class="line">	Wangye&#123;x:String,y:String&#125;,</span><br><span class="line">&#125;</span><br><span class="line">impl Yiren&#123;</span><br><span class="line">	fn call( &amp;self ) -&gt; &amp;str&#123;</span><br><span class="line">		match self&#123;</span><br><span class="line">			Yiren::Fengbaobao(x) =&gt; &#123;</span><br><span class="line">				println!(&quot;No&#123;&#125;&quot;,x);</span><br><span class="line">				&quot;风后奇门&quot;</span><br><span class="line">			&#125;</span><br><span class="line">			Yiren::Zhangchulan(t) =&gt; &#123;</span><br><span class="line">				println!(&quot;&#123;&#125; 张楚岚&quot;,t);</span><br><span class="line">				&quot;炁体源流&quot;</span><br><span class="line">			&#125;</span><br><span class="line">			Yiren::Wangye&#123;x,y&#125; =&gt; &#123;</span><br><span class="line">				println!(&quot;&#123;&#125;,&#123;&#125;!&quot;,x,y);</span><br><span class="line">				&quot;Mistery&quot;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">	let m1 = Yiren::Wangye&#123;x:&quot;常应常静&quot;.to_string(),y:&quot;常清静矣&quot;.to_string()&#125;; // construct m1:Yiren</span><br><span class="line">	let val1 = m1.call_name(); // recieve value returned</span><br><span class="line">	</span><br><span class="line">	let m2 = Yiren::Zhangchulan(&quot;不摇碧莲&quot;.to_string());</span><br><span class="line">	let val2 = m2.call_name();</span><br><span class="line">	</span><br><span class="line">	let m3 = Yiren::Fengbaobao(1);</span><br><span class="line">	let val3 = m3.call_name();</span><br><span class="line">	println!(&quot;capbilities are &#123;&#125;,&#123;&#125;,&#123;&#125;&quot;,val1,val2,val3); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、Option-Result"><a href="#2、Option-Result" class="headerlink" title="2、Option &amp; Result"></a>2、Option &amp; Result</h2><h3 id="Option-Maybe-a-value-or-maybe-null"><a href="#Option-Maybe-a-value-or-maybe-null" class="headerlink" title="Option: Maybe a value or maybe null"></a>Option: Maybe a value or maybe null</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Option&lt;T&gt; &#123;</span><br><span class="line">    Some(T),</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">	let num: Option&lt;i32&gt; = Some(3);</span><br><span class="line">    let none: Option&lt;usize&gt; = None;</span><br><span class="line">    match num&#123;</span><br><span class="line">	    Some(val) =&gt; &#123;println!(&quot;value is &#123;&#125;&quot;,val);&#125;,</span><br><span class="line">	    None =&gt; &#123;println!(&quot;Null&quot;);&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>E.g.:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let map:HashMap&lt;&amp;str, usize&gt; = HashMap::new();</span><br><span class="line">let a: Option&lt;&amp;usize&gt; = map.get(&quot;a&quot;); // a maybe none</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let v = vec![1,2,3];</span><br><span class="line">let last: Option&lt;&amp;i32&gt; = v.iter().last(); // last maybe none</span><br></pre></td></tr></table></figure>
<h3 id="Result-Operation-Success-value-or-Fail-info"><a href="#Result-Operation-Success-value-or-Fail-info" class="headerlink" title="Result: Operation Success-value or Fail-info"></a>Result: Operation Success-value or Fail-info</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Result&lt;T,E&gt; &#123;</span><br><span class="line">	OK(T),</span><br><span class="line">	Err(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">	let num: Result&lt;usize,()&gt; = Ok(3);</span><br><span class="line">	match num&#123;</span><br><span class="line">		Ok(t) =&gt; &#123;println!(&quot;&#123;&#125;&quot;,t);&#125;,</span><br><span class="line">		Err(_) =&gt; &#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>E.g.:<br>Note: <code>a.parse()</code> number_str -&gt; usize</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let num_str = &quot;42&quot;;</span><br><span class="line">    let result: Result&lt;usize, std::num::ParseIntError&gt; = number_str.parse();</span><br><span class="line">    match result &#123;</span><br><span class="line">        Ok(number) =&gt; &#123;println!(&quot;successful &#123;&#125;&quot;, number);&#125;,</span><br><span class="line">        Err(e) =&gt; &#123;println!(&quot;failed: &#123;&#125;&quot;, e);&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() -&gt; Result&lt;(),()&gt; &#123;</span><br><span class="line">	println!(&quot;love&quot;);</span><br><span class="line">	Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Option-Result"><a href="#Option-Result" class="headerlink" title="Option &lt;–&gt; Result"></a>Option &lt;–&gt; Result</h3><h4 id="Option-Result-1"><a href="#Option-Result-1" class="headerlink" title="Option -&gt; Result"></a>Option -&gt; Result</h4><p><code>result = opt_some.ok_or(&quot;error&quot;)</code><br><code>Some(val)-&gt;Ok(val)</code>  <code>None-&gt;Err(e)</code><br><code>assert_eq!(a,b)</code>: a&#x3D;b √  a!&#x3D;b panic!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let opt_some: Option&lt;i32&gt; = Some(42);</span><br><span class="line">    let result_from_some: Result&lt;i32,&amp;str&gt; = opt.ok_or(&quot;Value was None&quot;); //Err-str</span><br><span class="line">	</span><br><span class="line">	let opt_none: Option&lt;i32&gt; = None;</span><br><span class="line">    let result_from_none: Result&lt;i32,&amp;str&gt; = none.ok_or(&quot;Value was None&quot;); </span><br><span class="line">    </span><br><span class="line">    match result_from_some&#123;</span><br><span class="line">        Ok(v) =&gt; println!(&quot;Value: &#123;&#125;&quot;, v), </span><br><span class="line">        Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e),</span><br><span class="line">    &#125;</span><br><span class="line">    match result_from_none &#123;</span><br><span class="line">        Ok(v) =&gt; println!(&quot;Value: &#123;&#125;&quot;, v),</span><br><span class="line">        Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Result-Option"><a href="#Result-Option" class="headerlink" title="Result -&gt; Option"></a>Result -&gt; Option</h4><p><code>opt = result_ok.ok()</code><br><code>Ok(val)-&gt;Some(val)</code>  <code>Err(e)-&gt;None</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let result_ok: Result&lt;i32, &amp;str&gt; = Ok(42);</span><br><span class="line">    let opt_from_ok: Option&lt;i32&gt; = result_ok.ok();</span><br><span class="line">	</span><br><span class="line">	let result_err: Result&lt;i32, &amp;str&gt; = Err(&quot;Error accured&quot;);</span><br><span class="line">    let opt_from_err = result_err.ok();</span><br><span class="line"></span><br><span class="line">	match opt_from_ok&#123;</span><br><span class="line">		Some(v) =&gt; println!(&quot;Value: &#123;&#125;&quot;,v),</span><br><span class="line">		None =&gt; println!(&quot;None&quot;),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="Commonly-used-API"><a href="#Commonly-used-API" class="headerlink" title="Commonly  used API"></a>Commonly  used API</h3><p><code>x.map(|x|f(x))</code> return Option or Result<br><code>x.unwrap();</code>  <code>x.expect(&quot;msg&quot;)</code>  if None-&gt;panic!<br><code>x.and_then(|x|Some(f(x)))</code> return Option: Some(f(x)) or None<br><code>x.and_then(|x|Ok(f(x)))</code> return Result: Ok(f(x)) or Err(e)<br><code>let x = None; x.or_else(|| Some(1))</code> if None-&gt;Some(n)<br><code>let x = Err(&quot;error&quot;); x.or_else(|_| Ok(1))</code> if Err-&gt;Ok(n) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">	let x: Option&lt;i32&gt; = Some(1);</span><br><span class="line">	let y: Option&lt;i32&gt; = x.map(|x| x+1);</span><br><span class="line">	let a = x.unwrap();</span><br><span class="line">	let z = x.and_then(|x|x+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Size-of-Enum"><a href="#Size-of-Enum" class="headerlink" title="Size of Enum"></a>Size of Enum</h3><p>Note : Print the size of enum</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::mem;</span><br><span class="line"></span><br><span class="line">enum My_enum1 &#123;</span><br><span class="line">    A(u8, u8), //2</span><br><span class="line">    B,  // space to store the discriminant 1</span><br><span class="line">    C &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum My_enum2 &#123;</span><br><span class="line">    A = 255, //0 according to compilation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum My_enum3 &#123;</span><br><span class="line">    A = 255,</span><br><span class="line">    B, // B is assiged 256-&gt; u16 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Size of My_enum1: &#123;&#125;&quot;, mem::size_of::&lt;My_enum1&gt;());//3</span><br><span class="line">    println!(&quot;Size of My_enum2: &#123;&#125;&quot;, mem::size_of::&lt;My_enum2&gt;());//0</span><br><span class="line">    println!(&quot;Size of My_enum3: &#123;&#125;&quot;, mem::size_of::&lt;My_enum3&gt;());//2</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>data type</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay1 Enviroment Build and Test</title>
    <url>/2024/08/26/Rust-Day1/</url>
    <content><![CDATA[<h1 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h1><h2 id="1、Build-Rust-Environment"><a href="#1、Build-Rust-Environment" class="headerlink" title="1、Build Rust Environment"></a>1、Build Rust Environment</h2><h3 id="Windows："><a href="#Windows：" class="headerlink" title="Windows："></a>Windows：</h3><p>① Build C&#x2F;C++Enviroment via VScode <a href="https://blog.csdn.net/m0_62721576/article/details/127207028?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172459320916800175769039%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172459320916800175769039&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127207028-null-null.142%5Ev100%5Epc_search_result_base6&utm_term=vscode%E9%85%8D%E7%BD%AEc/c++%E7%8E%AF%E5%A2%83&spm=1018.2226.3001.4187">Tutorials</a>   <br>② Build Local Environment for Rust <a href="https://blog.csdn.net/jiang1126/article/details/135268741?ops_request_misc=&request_id=&biz_id=102&utm_term=windows%20%E6%90%AD%E5%BB%BArust&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-135268741.142%5Ev100%5Epc_search_result_base6&spm=1018.2226.3001.4187">Tutorials</a>   <br>③ Try to Run  </p>
<h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h3><p><a href="https://blog.csdn.net/qq_29901385/article/details/133607985?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172459673716800222890822%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172459673716800222890822&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-133607985-null-null.142%5Ev100%5Epc_search_result_base6&utm_term=MacOS%20rust&spm=1018.2226.3001.4187">Tutorials</a>    </p>
<h3 id="Common-Demand"><a href="#Common-Demand" class="headerlink" title="Common Demand"></a>Common Demand</h3><ul>
<li>Update：<code>rustup update</code>  </li>
<li>Uninstall：<code>rustup self uinstall</code>    </li>
<li>View Document：<code>rustup doc</code>    </li>
<li>Create Folder：<code>mkdir hello_world</code>  </li>
<li>Create File：main.rs<br><strong>Note：Set rust、rust-analyzer、crates、even better TOML</strong>  via Extensions in VScode</li>
</ul>
<h2 id="2、Test"><a href="#2、Test" class="headerlink" title="2、Test"></a>2、Test</h2><p>Create Folder <code>Rustcode</code>to store code.</p>
<h3 id="①-Mannually-Create-Project"><a href="#①-Mannually-Create-Project" class="headerlink" title="① Mannually Create Project"></a>① Mannually Create Project</h3><p>Mannually create folder <code>hello_world</code> under <code>Rustcode</code> , and create file <code>main.rs</code> under it.</p>
<ul>
<li>Coding under <code>main.rs</code>：    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main()  </span><br><span class="line">&#123;    </span><br><span class="line">    println!(&quot;hello world!&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
<li>Compile by entering commands in Teminnal <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd hello_world</span><br><span class="line">rustc main.rs</span><br></pre></td></tr></table></figure></li>
<li>After successful compilation, a binary executable file <code>main</code> will be output, which can be run directly<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="②-Atomatically-create-project-via-Cargo"><a href="#②-Atomatically-create-project-via-Cargo" class="headerlink" title="② Atomatically create project via Cargo"></a>② Atomatically create project via Cargo</h3><p>Run Terminal under folder <code>Rustcode</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo new hello_cargo</span><br><span class="line">cd hello_cargo</span><br><span class="line">code ./</span><br></pre></td></tr></table></figure>
<p>(1) Code in VScode Terminal</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>
<p>Executable file <code>hello_cargo</code> will be formed under folder <code>debug</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./target/debug/hello_cargo</span><br></pre></td></tr></table></figure>
<p>(2) Compile + Run via VScode Terminal </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>
<p>(3) File Optimisation</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>
<p><code>exe</code> flie formed under foler <code>release</code></p>
<p>Note：<br><code>cargo build</code> 和<code>cargo run</code> intend to Development, in case you need quick rebuild several times.<br><code>cargo release</code> intends to Consumers who won’t rebuild project that much and hope the code run as fast as possible.</p>
<h3 id="③-Adding-Dependencies"><a href="#③-Adding-Dependencies" class="headerlink" title="③ Adding Dependencies"></a>③ Adding Dependencies</h3><p><code>Crates</code> is a rust code library non self-executing<br>File name <code>Cargo.tomal</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[depencies]</span><br><span class="line">rand = &quot;0.8.5&quot;</span><br></pre></td></tr></table></figure>
<p>Rebuild project <code>cargo build</code><br>Dependencies will be acquired from Crates and written to file <code>Cargo.lock</code></p>
<p>Note: Cargo will use versions set in <code>Cargo.lock</code> in priority. Update Crates:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo update </span><br></pre></td></tr></table></figure>

<h3 id="④-Configuring-Domestic-Mirrors-Users-in-China-Mainland"><a href="#④-Configuring-Domestic-Mirrors-Users-in-China-Mainland" class="headerlink" title="④ Configuring Domestic Mirrors Users in China Mainland"></a>④ Configuring Domestic Mirrors <strong>Users in China Mainland</strong></h3><p><a href="https://blog.csdn.net/qq_28550263/article/details/130758057?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-1-130758057-blog-130759091.235%5Ev43%5Econtrol&spm=1001.2101.3001.4242.2&utm_relevant_index=4">Tutorials</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>enviroment</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay14 Module</title>
    <url>/2024/09/07/Rust-Day14/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_package/</span><br><span class="line">├── Cargo.toml: A configuration file that defines the package metadata, dependencies, and build configuration.</span><br><span class="line">├── Cargo.lock: Exact version</span><br><span class="line">├── src/:Rust source code</span><br><span class="line">│   ├── main.rs:binary crates (cargo run)</span><br><span class="line">│   └── lib.rs:library crates	</span><br><span class="line">│   └── bin.rs:several binary crates</span><br><span class="line">├── tests/</span><br><span class="line">│   └── integration_test.rs</span><br><span class="line">├── examples/</span><br><span class="line">│   └── example.rs</span><br><span class="line">├── benches/</span><br><span class="line">│   └── benchmark.rs</span><br><span class="line">├── docs/</span><br><span class="line">│   └── README.md</span><br><span class="line">├── .cargo/</span><br><span class="line">│   └── config.toml</span><br><span class="line">└── LICENSE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h4><ul>
<li>Imports: <code>use std::io;</code></li>
<li>Main function: start point</li>
<li>Error handling <code>main()-&gt;Result&lt;(),std::io::Error&gt;</code></li>
<li>External Crates and storage</li>
</ul>
<h4 id="lib-rs"><a href="#lib-rs" class="headerlink" title="lib.rs"></a>lib.rs</h4><ul>
<li><strong>Module</strong>:<br><code>mod</code>  <code>pub</code>  <code>use</code>  <code>as</code><br>visibility: <code>private(default)</code> <code>pub(crate)</code> <code>pub(in path) e.g.pub(in crate::A)</code> <code>pub use A</code><br>path:  absolute <code>crate::A::fun_a();</code><br>  relative: B{<code>use super::fun_a;</code> or <code>super::fun_a();</code>  <code>self::fun_b();</code>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use A::B::C::fun_c;</span><br><span class="line">use A::&#123;B::log as logb,log&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">	fun_c(); // call directly</span><br><span class="line">&#125;</span><br><span class="line">mod A &#123;</span><br><span class="line">	const a = 1;</span><br><span class="line">	pub fn log()&#123;&#125;</span><br><span class="line">	pub fn fun_a&#123;&#125; // without pub， can‘t be called by other mod</span><br><span class="line">	pub mod B &#123;</span><br><span class="line">		pub fn fun_b()&#123;&#125; //B call A&#x27;s private function √</span><br><span class="line">		pub fn log()&#123;&#125;   </span><br><span class="line">		pub mod C&#123;</span><br><span class="line">			pub fn fun_c()&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="worksapce"><a href="#worksapce" class="headerlink" title="worksapce"></a>worksapce</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//toml</span><br><span class="line">[workspace] </span><br><span class="line">members = [ </span><br><span class="line">	&quot;package1&quot;, </span><br><span class="line">	&quot;package2&quot;, </span><br><span class="line">	&quot;path/to/another/package&quot;, </span><br><span class="line">	]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_workspace/</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── package1/</span><br><span class="line">│   └── Cargo.toml</span><br><span class="line">└── package2/</span><br><span class="line">    └── Cargo.toml</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay11 Rust data type—Struct</title>
    <url>/2024/08/26/Rust-Day11/</url>
    <content><![CDATA[<h2 id="1、Definition"><a href="#1、Definition" class="headerlink" title="1、Definition"></a>1、Definition</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct User&#123;</span><br><span class="line">	name: String,</span><br><span class="line">	balance: i32,</span><br><span class="line">	active: bool</span><br><span class="line">&#125;</span><br><span class="line">// Turple struct</span><br><span class="line">struct Color&#123;i32,i32,i32&#125;</span><br><span class="line">// Unit Struct</span><br><span class="line">struct Alwaysequal;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">	let mut user1 = User&#123;</span><br><span class="line">		name: String::from(&quot;王也&quot;),</span><br><span class="line">		balance: 1000,</span><br><span class="line">		active: true,</span><br><span class="line">	&#125;;</span><br><span class="line">	user1.name = String::from(&quot;张楚岚&quot;);</span><br><span class="line">	</span><br><span class="line">	// struct Update method </span><br><span class="line">	let mut user2 = User&#123;</span><br><span class="line">		name: String::from(&quot;冯宝宝&quot;), //ownership transferred</span><br><span class="line">		..user1</span><br><span class="line">	&#125;; </span><br><span class="line"></span><br><span class="line">	let col = Color(0,0,0);</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,col.0)</span><br><span class="line"></span><br><span class="line">	let oject = Alwaysequal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、Ownership"><a href="#2、Ownership" class="headerlink" title="2、Ownership"></a>2、Ownership</h3><ul>
<li>Owning fields : struct instance and all it’s fields share the same lifetime </li>
<li>Dynamic memory: No Copy– ownership transfferd</li>
<li>Borrowed fields: If there are fields like <code>&amp;T or &amp;mut T</code>  Lifetime has to be annotated. <ul>
<li><strong>vv &#x3D; &amp;v,  lifeime v≥vv</strong></li>
<li>&lt;’a&gt;–&gt; <strong>Reference fields lifetime ≥ Struct lifetime</strong></li>
</ul>
</li>
<li>If the ownership of one field changed, the whole struct can’t be added value&#x2F;call, but single field is ok <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct User&#123;</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let mut user1 = User&#123;</span><br><span class="line">    name: String::from(&quot;王也&quot;),</span><br><span class="line">    &#125;; </span><br><span class="line">    // Lifetime: user1-main&#123;&#125; user1.name belongs to user1</span><br><span class="line">    </span><br><span class="line">    // let mut name = user1.name; // ownership transferred </span><br><span class="line">    </span><br><span class="line">    let mut name: &amp; mut String = &amp; mut user1.name;</span><br><span class="line">    // name is mut address</span><br><span class="line">    // Lifetime: name ≤ user1.name</span><br><span class="line">      </span><br><span class="line">    *name = String::from(&quot;张楚岚&quot;); // change the address value</span><br><span class="line">    </span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,user1.name);// changed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct User&lt;&#x27;a&gt; &#123;</span><br><span class="line">    username: &amp;&#x27;a str,  </span><br><span class="line">    email: &amp;&#x27;a str,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let email: String = String::from(&quot;Username@gail.com&quot;);</span><br><span class="line">// email- dynamic, Lifetime-main&#123;&#125;</span><br><span class="line"></span><br><span class="line">    let username: &amp;str = &amp;email[0..=7];</span><br><span class="line">// username is a slice of email, Lifetime ≤ email</span><br><span class="line"></span><br><span class="line">	let user1 = User&#123;</span><br><span class="line">	    username = username;</span><br><span class="line">	    email = &amp;email;</span><br><span class="line">    &#125;</span><br><span class="line">// user1 lifetime ≤ &amp;email</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,user1.username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、Function"><a href="#3、Function" class="headerlink" title="3、Function"></a>3、Function</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: i32,</span><br><span class="line">    height: i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    // Instance funtion</span><br><span class="line">    fn ins_area( &amp;self )-&gt;i32&#123;</span><br><span class="line">        self.width * self.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add(&amp;mut self, a: i32) &#123;</span><br><span class="line">        self.width += a;</span><br><span class="line">        self.height += a;</span><br><span class="line">        println!(&quot;added area is &#123;&#125;&quot;,self.ins_area());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Rectangle&#123;</span><br><span class="line">    //Association function</span><br><span class="line">    fn new(width: i32, height: i32) -&gt; Rectangle &#123; </span><br><span class="line">	    Rectangle &#123; width, height &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    fn asso_area(a:i32,b:i32) -&gt; i32&#123;</span><br><span class="line">        a * b</span><br><span class="line">    &#125;</span><br><span class="line">    fn total_area(r1:&amp;Rectangle, r2:&amp;Rectangle) -&gt; i32 &#123;</span><br><span class="line">        r1.ins_area() + r2.ins_area()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    let mut m1 = Rectangle::new(10,10);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,m1.ins_area()); // call instance method</span><br><span class="line">    m1.add(2);</span><br><span class="line"></span><br><span class="line">    let area = Rectangle::asso_area(10, 5); //call association function</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、trait"><a href="#4、trait" class="headerlink" title="4、trait"></a>4、trait</h2><p>Act like an <strong>Interface</strong></p>
<ul>
<li>define<code>trait</code>** :<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trait Need_print&#123;</span><br><span class="line">	fn print_info( &amp;self ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>realize <code>trait</code> for struct: <code>impl TraitName for StructName</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Book &#123;</span><br><span class="line">    title: String,</span><br><span class="line">    author: String,</span><br><span class="line">&#125;</span><br><span class="line">struct Person &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: u8,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Need_print for Book &#123;</span><br><span class="line">    fn print_info(&amp;self) &#123;</span><br><span class="line">        println!(&quot;Book: &#123;&#125; by &#123;&#125;&quot;, self.title, self.author);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Need_print for Person &#123;</span><br><span class="line">    fn print_info(&amp;self) &#123;</span><br><span class="line">        println!(&quot;Person: &#123;&#125; is &#123;&#125; years old&quot;, self.name, self.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let my_book = Book &#123;</span><br><span class="line">        title: String::from(&quot;Rust&quot;),</span><br><span class="line">        author: String::from(&quot;John&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    let my_person = Person &#123;</span><br><span class="line">        name: String::from(&quot;Alice&quot;),</span><br><span class="line">        age: 30,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    my_book.print_info(); </span><br><span class="line">    my_person.print_info(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、print"><a href="#5、print" class="headerlink" title="5、print"></a>5、print</h2><h3 id="derive-Debug"><a href="#derive-Debug" class="headerlink" title="#[derive(Debug)]"></a>#[derive(Debug)]</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct User &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: u32,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User &#123;</span><br><span class="line">        name: String::from(&quot;Alice&quot;),</span><br><span class="line">        age: 30,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 使用 Debug 输出完整的结构体内容</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, user1);  // simplified</span><br><span class="line">    println!(&quot;&#123;:#?&#125;&quot;, user1); // beautified</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Customized-print-fmt"><a href="#Customized-print-fmt" class="headerlink" title="Customized print: fmt"></a>Customized print: <code>fmt</code></h3><h4 id="Display"><a href="#Display" class="headerlink" title="Display {}"></a>Display <code>&#123;&#125;</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::fmt;</span><br><span class="line"></span><br><span class="line">struct User &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl fmt::Display for User &#123;</span><br><span class="line">    fn fmt ( &amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123;</span><br><span class="line">        write!(f, &quot;User is &#123;&#125;, Age is &#123;&#125;&quot;, self.name, self.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user = User &#123;</span><br><span class="line">        name: String::from(&quot;Alice&quot;),</span><br><span class="line">        age: 30,</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, user); // directly print user</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Debug"><a href="#Debug" class="headerlink" title="Debug {:?}"></a>Debug <code>&#123;:?&#125;</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line"></span><br><span class="line">struct User &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: u32,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user = User &#123;</span><br><span class="line">        name: String::from(&quot;Alice&quot;),</span><br><span class="line">        age: 30,</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, user);  </span><br><span class="line">    println!(&quot;&#123;:#?&#125;&quot;, user); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E.g.:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::fmt;</span><br><span class="line">struct Rec&#123;</span><br><span class="line">	l:i32,</span><br><span class="line">	w:i32,</span><br><span class="line">&#125;</span><br><span class="line">impl fmt::Display for Rec&#123;</span><br><span class="line">	fn fmt( &amp;self, f:&amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result&#123;</span><br><span class="line">		for i in 0..self.l&#123;</span><br><span class="line">			let mut s = String::new();</span><br><span class="line">			for j in 0..self.w&#123;</span><br><span class="line">				s.push_str(&quot;*&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			write!(f,&quot;&#123;&#125;\n&quot;,s);</span><br><span class="line">		&#125;</span><br><span class="line">		Ok(())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">	let r = Rec&#123;</span><br><span class="line">		l:4,</span><br><span class="line">		w:3</span><br><span class="line">	&#125;;</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






















]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>data type</tag>
        <tag>struct</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay15&amp;16 Smart point</title>
    <url>/2024/09/08/Rust-Day15%20&amp;%20Day16/</url>
    <content><![CDATA[<p><strong>Smart pointer</strong>:<br>    Struct + Deref &amp; Drop trait</p>
<h2 id="Box-Box-a-Pointer-T-value"><a href="#Box-Box-a-Pointer-T-value" class="headerlink" title="Box&lt;T&gt; Box-a Pointer  T-value"></a><code>Box&lt;T&gt;</code> Box-a Pointer  T-value</h2><p>Note:<br>    T -&gt; Heap<br>    Pointer -&gt; Stack<br>    Single Ownership<br>    <code>Box::new</code> - allocate memory<br>    <code>Drop trait</code> - release memory	<br>Function:<br>    * Size is unknown, but needed<br>    * Transfer ownership without copy<br>    * Certain value if realize specialized trait</p>
<ul>
<li>Set up: <code>let b = Box::new(T)</code></li>
<li>Read: <code>*b</code></li>
<li>dynamic memory: <ul>
<li><code>let s: Box&lt;str&gt; = &quot;Hello&quot;.into();</code><ul>
<li><code>&quot; &quot;.into()</code>: <code>&amp;str-&gt;Box&lt;str&gt;</code></li>
</ul>
</li>
<li><code>let v: Box&lt;[i32]&gt; = vec![1,2,3].into_boxed_slice();</code><ul>
<li><code>v.into_boxed_slice()</code>: <code>Vec&lt;i32&gt;-&gt;Box&lt;i32&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>Ownership:<ul>
<li><code>let c: Box&lt;i32&gt; = b</code></li>
<li><code>let c: &amp;i32 = &amp;*b;</code></li>
</ul>
</li>
<li>Recuisive data structure:<br><code>enum&#123;Box&lt;enum&gt;&#125;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum List &#123;</span><br><span class="line">    Mybox(i32, Box&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let list: Box&lt;List&gt; = Box::new(List::Mybox(1, Box::new(List::Mybox(2, Box::new(List::Nil))))));</span><br><span class="line">    // *list -&gt; Mybox(1, Mybox(2, Nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Box + trait<ul>
<li><code>dyn</code>: Determine <em>Type</em> while <em>Run</em></li>
<li><code>let shape = vec!&lt;Box&lt;dyn Shape&gt;&gt; </code><ul>
<li><code>dyn Shape:</code> Shape’s object is unsure </li>
<li><code>for i: Box&lt;dyn shape&gt; in shape&#123;**i.trait_fn()**;&#125;</code>– polymorphic operation</li>
</ul>
</li>
<li>return Struct&#x2F;Enum with unknown size:  <code>struct TEST</code> <ul>
<li><code>return Box::new(TEST);</code> (<code>Box&lt;dyn Trait_name&gt;</code>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trait Shape &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Circle &#123;</span><br><span class="line">    radius: f64,</span><br><span class="line">&#125;</span><br><span class="line">struct Square &#123;</span><br><span class="line">    a: f64,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Shape for Circle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        3.14 * self.radius * self.radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Shape for Square &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        self.a * 4.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct TEST;</span><br><span class="line">impl Shape for TEST &#123;</span><br><span class="line">	fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">		3.333</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn get_test()-&gt;Box&lt;dyn Shape&gt;&#123;</span><br><span class="line">	Box::new(TEST)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let shapes: Vec&lt;Box&lt;dyn Shape&gt;&gt; = vec![</span><br><span class="line">        Box::new(Circle &#123; radius: 2.0 &#125;),Box::new(Square&#123;a:3.0&#125;), </span><br><span class="line">    ];</span><br><span class="line">    for shape: Box&lt;dyn shape&gt; in shapes &#123;</span><br><span class="line">        println!(&quot;Area: &#123;&#125;&quot;, shape.area());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	let test = get_test();</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,test.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trait Animal &#123;</span><br><span class="line">    fn speak(&amp;self) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Dog;</span><br><span class="line"></span><br><span class="line">impl Animal for Dog &#123;</span><br><span class="line">    fn speak(&amp;self) -&gt; String &#123;</span><br><span class="line">        String::from(&quot;Woof!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn get_animal() -&gt; Box&lt;dyn Animal&gt; &#123;</span><br><span class="line">    Box::new(Dog)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let animal = get_animal();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, animal.speak()); // 输出 &quot;Woof!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>Drop</strong>  <strong>Deref</strong>  <strong>DerefMut</strong> –&gt;<strong>Customized Type</strong><br><code>impl xxx for struct_name</code></p>
<ul>
<li>Drop: Exacute when a value leave scope block -&gt; release rescource</li>
<li>Deref: <code>let b = Mytype::num(6)</code> <code>*b</code>√</li>
<li>DerefMut: <code>let mut b = Box::new(10); *b += 1;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::ops::Deref;</span><br><span class="line">use std::ops::DerefMut;</span><br><span class="line"></span><br><span class="line">struct Yiren&#123;</span><br><span class="line">    num:i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Drop for Yiren&#123;</span><br><span class="line">    fn drop(&amp;mut self) &#123;</span><br><span class="line">        println!(&quot;drop &#123;&#125;&quot;,self.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Deref for Yiren&#123;</span><br><span class="line">    type Target = i32;</span><br><span class="line">    fn deref(&amp;self) -&gt; &amp;i32&#123;</span><br><span class="line">        &amp;self.num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl DerefMut for Yiren &#123;</span><br><span class="line">    fn deref_mut(&amp;mut self) -&gt; &amp;mut i32 &#123;</span><br><span class="line">        &amp;mut self.num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut me = Yiren &#123; num: 36 &#125;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,*me);</span><br><span class="line">    *me += 1;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,*me);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  堆上分配比栈上分配更适合大型数据</p>
</li>
</ul>
<ul>
<li><strong>栈的限制</strong>：栈的内存是固定的，通常在几 MB 的范围内。栈上的数据分配和释放速度很快，但由于内存限制，不能处理非常大的数据。</li>
<li><strong>堆的优势</strong>：堆的内存容量较大，适合存储大型数据结构。虽然堆分配和释放速度可能较慢，但可以处理更大的数据量。</li>
</ul>
<h4 id="Homework"><a href="#Homework" class="headerlink" title="Homework"></a>Homework</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Node&#123;</span><br><span class="line">    File(FolderNode), //文件</span><br><span class="line">    Folder(FolderNode,Vec&lt;Box&lt;Node&gt;&gt;), //文件夹 一个文件夹-节点1，其中包含子节点[1.1，1.2，1.3...]</span><br><span class="line">&#125;</span><br><span class="line">trait FileSystem&#123;</span><br><span class="line">    fn create_file(f:FolderNode)-&gt;Self;</span><br><span class="line">    fn create_folder(f:FolderNode)-&gt;Self;</span><br><span class="line">    fn add_son(&amp;mut self,son: Node);</span><br><span class="line">    fn list_contents(&amp;self,n:i32);</span><br><span class="line">&#125;</span><br><span class="line">struct FolderNode&#123;</span><br><span class="line">    name:String,</span><br><span class="line">    contents:String,</span><br><span class="line">&#125;</span><br><span class="line">impl FileSystem for Node&#123;</span><br><span class="line">    fn create_file(f:FolderNode)-&gt;Self &#123;</span><br><span class="line">        Node::File(f)</span><br><span class="line">    &#125;</span><br><span class="line">    fn create_folder(f:FolderNode)-&gt;Self &#123;</span><br><span class="line">        Node::Folder(f,Vec::new())</span><br><span class="line">    &#125;</span><br><span class="line">    fn add_son(&amp; mut self,son: Node) &#123;</span><br><span class="line">        if let Node::Folder(name,ref mut sons ) = self &#123;</span><br><span class="line">            sons.push(Box::new(son));</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            panic!(&quot;Error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fn list_contents(&amp;self,n:i32) &#123;</span><br><span class="line">        let space = &quot; &quot;.repeat(n.try_into().unwrap());</span><br><span class="line">        match self&#123;</span><br><span class="line">            Node::File(f) =&gt; &#123;</span><br><span class="line">                println!(&quot;&#123;&#125; &#123;&#125;: &#123;&#125;&quot;,space,f.name,f.contents);</span><br><span class="line">            &#125;</span><br><span class="line">            Node::Folder(f, sons) =&gt; &#123;</span><br><span class="line">                println!(&quot;&#123;&#125; &#123;&#125;:&quot;,space,f.name);</span><br><span class="line">                for son in sons&#123;</span><br><span class="line">                    son.list_contents(n+2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    // 创建根目录</span><br><span class="line">    let f_dir1 = FolderNode &#123; name: &quot;Dic1&quot;.to_string(), contents: &quot; &quot;.to_string() &#125;;</span><br><span class="line">    let f_dir2 = FolderNode &#123; name: &quot;Dic2&quot;.to_string(), contents: &quot; &quot;.to_string() &#125;;</span><br><span class="line">    let f_file1 = FolderNode &#123; name: &quot;file1&quot;.to_string(), contents: &quot;一鼓作气&quot;.to_string() &#125;;</span><br><span class="line">    let f_file2= FolderNode &#123; name: &quot;file2&quot;.to_string(), contents: &quot;两世为人&quot;.to_string() &#125;;</span><br><span class="line">    let f_file3 = FolderNode &#123; name: &quot;file3&quot;.to_string(), contents: &quot;三人成虎&quot;.to_string() &#125;;</span><br><span class="line">    let f_file4 = FolderNode &#123; name: &quot;file4&quot;.to_string(), contents: &quot;四面楚歌&quot;.to_string() &#125;;</span><br><span class="line">  </span><br><span class="line">    let mut dir1 = Node::create_folder(f_dir1);</span><br><span class="line">    dir1.add_son(Node::create_file(f_file1));</span><br><span class="line">    dir1.add_son(Node::create_file(f_file2));</span><br><span class="line"></span><br><span class="line">    let mut dir2 = Node::create_folder(f_dir2);</span><br><span class="line">    dir2.add_son(Node::create_file(f_file3));</span><br><span class="line">    dir2.add_son(Node::create_file(f_file4));</span><br><span class="line">    </span><br><span class="line">    dir1.add_son(dir2);</span><br><span class="line">    </span><br><span class="line">    dir1.list_contents(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Rc-strong"><a href="#Rc-strong" class="headerlink" title="Rc&lt;T&gt;:strong"></a><code>Rc&lt;T&gt;</code>:strong</h2><p>Note:<br><code>use std::rc::Rc;</code></p>
<ul>
<li>Function：<code>&amp;</code> <strong>counter</strong><ul>
<li>Strong counter: when num &#x3D; 0, memory release<ul>
<li>Weak(num won’t increase)</li>
</ul>
</li>
<li>Only <strong>Immute &amp;</strong>: Combine with RefCell to change <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code></li>
</ul>
<ul>
<li>Share— <strong>Multi-ownership</strong></li>
</ul>
</li>
<li>Single-thread</li>
</ul>
<ul>
<li>Set up: <code>let a  = Rc::new(10)</code></li>
<li>Clone: <code>let a1 = Rc::clone(&amp;a)</code></li>
<li><code>Rc::strong_count(&amp;r)</code> strong &amp; counts</li>
<li><code>Rc::weak_count(&amp;r)</code> weak &amp; counts</li>
<li><code>Rc::downgrade(&amp;r)</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::rc::Rc;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let r: Rc&lt;String&gt; = Rc::new(String::from(&quot;Hello&quot;));</span><br><span class="line">    let r1 = Rc::clone(&amp;r);</span><br><span class="line">    let r2 = Rc::clone(&amp;r);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Reference count: &#123;&#125;&quot;, Rc::strong_count(&amp;r)); // 3</span><br><span class="line"></span><br><span class="line">    println!(&quot;Text: &#123;&#125;&quot;, *r);</span><br><span class="line">    println!(&quot;Clone: &#123;&#125;&quot;, *r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line">use std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">struct Node &#123;</span><br><span class="line">    value: i32,</span><br><span class="line">    next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">    prev: Option&lt;Weak&lt;RefCell&lt;Node&gt;&gt;&gt;, //  Weak </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    </span><br><span class="line">    let one = Rc::new(RefCell::new(Node &#123; value: 1, next: None, prev: None &#125;)); // one strong 1</span><br><span class="line">    let two = Rc::new(RefCell::new(Node &#123; value: 2, next: None, prev: None &#125;));// two strong 1</span><br><span class="line"></span><br><span class="line">    // cross-reference</span><br><span class="line">    one.borrow_mut().next = Some(Rc::clone(&amp;two)); //two strong 2</span><br><span class="line">    two.borrow_mut().prev = Some(Rc::downgrade(&amp;one)); // one weak 1  </span><br><span class="line"></span><br><span class="line">    // 打印强引用和弱引用的计数</span><br><span class="line">    println!(</span><br><span class="line">        &quot;one strong: &#123;&#125;, weak: &#123;&#125;&quot;,</span><br><span class="line">        Rc::strong_count(&amp;one),</span><br><span class="line">        Rc::weak_count(&amp;one)</span><br><span class="line">    );</span><br><span class="line">    println!(</span><br><span class="line">        &quot;two strong: &#123;&#125;, weak: &#123;&#125;&quot;,</span><br><span class="line">        Rc::strong_count(&amp;two),</span><br><span class="line">        Rc::weak_count(&amp;two)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Arc"><a href="#Arc" class="headerlink" title="Arc&lt;T&gt;"></a><code>Arc&lt;T&gt;</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::sync::Arc;</span><br><span class="line">use std::thread;</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>&amp; Counter：clone, increase &amp; num, <strong>without copying value</strong></li>
<li>Multi-thread</li>
<li>Only Immute &amp;</li>
</ul>
<p><code>Arc::new()</code><br><code>Arc::clone(&amp;a)</code><br><code>thread::spawn()</code> Set up a new thread<br><code>move ||</code> : Closure <code>FnOnce</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::sync::Arc;</span><br><span class="line">use std::thread;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a: Arc&lt;String&gt; = Arc::new(String::from(&quot;Hello&quot;));</span><br><span class="line">    let mut t = vec![];</span><br><span class="line">    for _ in 0..5 &#123;</span><br><span class="line">        let a1 = Arc::clone(&amp;a);</span><br><span class="line">        let tt = thread::spawn(move || &#123;</span><br><span class="line">            println!(&quot;Text in thread: &#123;&#125;&quot;, *a1);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.push(tt);</span><br><span class="line">    &#125;</span><br><span class="line">    for tt in t &#123;</span><br><span class="line">        tt.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">// main thread counter</span><br><span class="line">    println!(&quot;Reference count: &#123;&#125;&quot;, Arc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell&lt;T&gt;"></a><code>RefCell&lt;T&gt;</code></h3><p><code>use std::cell::RefCell;</code><br>Note:</p>
<ul>
<li><strong>Mut + Immut √</strong></li>
<li>Compile while run<br>Set up: <code>let mut r = RefCell::new(10)</code><br>Read <strong><code>RefCell&lt;T&gt;</code></strong>:<br>  <code>let a: RefMut&lt;&#39;_,i32&gt; = r.borrow_mut(); return &amp; of T   </code>let b: Ref&lt;’_,i32&gt; &#x3D; r.borrow();<code>   </code>*a +&#x3D; *b;&#96;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">struct Person &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: RefCell&lt;i32&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Person &#123;</span><br><span class="line">    fn new(name: String, age: i32) -&gt; Self &#123;</span><br><span class="line">        Person &#123;</span><br><span class="line">            name,</span><br><span class="line">            age: RefCell::new(age),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fn add_age(&amp;self) &#123;</span><br><span class="line">        *self.age.borrow_mut() += 1; //MUT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let person = Person::new(&quot;Alice&quot;.to_string(), 30);</span><br><span class="line">    println!(&quot;Person&#x27;s name is &#123;&#125;&quot;, person.name);</span><br><span class="line">    person.add_age();</span><br><span class="line">    println!(&quot;Person&#x27;s age is now &#123;&#125;&quot;, *person.age.borrow()); //IMMUT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>smart pointer</tag>
        <tag>Box</tag>
        <tag>Rc</tag>
        <tag>Arc</tag>
        <tag>RefCell</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay12 Paterning Match</title>
    <url>/2024/09/04/Rust-Day12/</url>
    <content><![CDATA[<h2 id="1、Basic-pattern"><a href="#1、Basic-pattern" class="headerlink" title="1、Basic pattern"></a>1、Basic pattern</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match value &#123;</span><br><span class="line">    pattern1 =&gt; expression1,</span><br><span class="line">    pattern2 =&gt; expression2,</span><br><span class="line">    _ =&gt; default_expression, // 默认模式（可选），匹配所有剩余情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="match-integer-or-string"><a href="#match-integer-or-string" class="headerlink" title="match integer or string"></a>match integer or string</h3><ul>
<li><strong>(store in Heap: match –&gt;ownership transferred)</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">	let s = String::from(&quot;hello&quot;);</span><br><span class="line">    match s&#123;</span><br><span class="line">        var =&gt; println!(&quot;&#123;&#125;&quot;,var),</span><br><span class="line">        _ =&gt; println!(&quot;none&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">    //println!(&quot;&#123;&#125;&quot;,s); // ownership transferred</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>match arms: constant or simple mode</strong> (<code>Stirng::from(&quot;A&quot;)</code> × )<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let num = 3;</span><br><span class="line">    match num &#123;</span><br><span class="line">        1 =&gt; println!(&quot;One&quot;),</span><br><span class="line">        2 =&gt; println!(&quot;Two&quot;),</span><br><span class="line">        3 =&gt; println!(&quot;Three&quot;),</span><br><span class="line">        4..=10 =&gt; println!(&quot;Between 4 and 10&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;Other&quot;), </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">	let s = String::from(&quot;A&quot;);</span><br><span class="line">	match s.as_str &#123;</span><br><span class="line">		&quot;A&quot; =&gt; println!(&quot;upercase&quot;);</span><br><span class="line">		&quot;a&quot; =&gt; println!(&quot;lowercase&quot;);</span><br><span class="line">		_ =&gt; println!(&quot;Error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="match-turple"><a href="#match-turple" class="headerlink" title="match turple"></a>match turple</h3><p>Note:</p>
<ul>
<li>Deconstruct elements <code>one ( , ) - one occasion</code></li>
<li>Condition guard : <code>if</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let p = (1, -1);</span><br><span class="line">    match p &#123;</span><br><span class="line">        (x, y) if x == y =&gt; println!(&quot;Equal values: (&#123;&#125;, &#123;&#125;)&quot;, x, y),</span><br><span class="line">        (x, y) if x + y == 0 =&gt; println!(&quot;Sum is zero: (&#123;&#125;, &#123;&#125;)&quot;, x, y),</span><br><span class="line">        _ =&gt; println!(&quot;Different values: (&#123;&#125;, &#123;&#125;)&quot;, pair.0, pair.1),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="match-struct"><a href="#match-struct" class="headerlink" title="match struct"></a>match struct</h3><p>Note:</p>
<ul>
<li>Deconstruct fields – <code>one struct&#123;&#125; - one occasion</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p = Point &#123; x: 0, y: 7 &#125;;</span><br><span class="line">    match p &#123;</span><br><span class="line">        Point &#123; x, y: 0 &#125; =&gt; println!(&quot;On the x-axis at &#123;&#125;&quot;, x),</span><br><span class="line">        Point &#123; x: 0, y &#125; =&gt; println!(&quot;On the y-axis at &#123;&#125;&quot;, y),</span><br><span class="line">        Point &#123; x, y &#125; =&gt; println!(&quot;Point at (&#123;&#125;, &#123;&#125;)&quot;, x, y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="match-enum"><a href="#match-enum" class="headerlink" title="match enum"></a>match enum</h3><p>Note: </p>
<ul>
<li>Deconstruct variants – <code>one variant - one occasion</code></li>
<li><code>Enum::A&#123;x:var1 @10..20, y:var2 @10..20&#125; =&gt; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,var1,var2)</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32, i32, i32),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let msg = Message::Move &#123; x: 10, y: 20 &#125;;</span><br><span class="line"></span><br><span class="line">    match msg &#123;</span><br><span class="line">        Message::Quit =&gt; println!(&quot;Quit&quot;),</span><br><span class="line">        Message::Move &#123; x: var1 @0..5, y: var2 @0..5 &#125; =&gt; println!(&quot;Move to (&#123;&#125;, &#123;&#125;)&quot;, var1, var2),</span><br><span class="line">        Message::Write(text) =&gt; println!(&quot;Text message: &#123;&#125;&quot;, text),</span><br><span class="line">        Message::ChangeColor(r, g, b) =&gt; println!(&quot;Change color to RGB(&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;, r, g, b),</span><br><span class="line">        _ =&gt; println!(&quot;none&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、if-let"><a href="#2、if-let" class="headerlink" title="2、if let"></a>2、if let</h2><h3 id="Option"><a href="#Option" class="headerlink" title="Option&lt;T&gt;"></a><code>Option&lt;T&gt;</code></h3><p><code>if Some(x) = num &#123;&#125; else&#123;&#125;</code> if num type is <code>Option&lt;T&gt;</code>, fetch value <code>x</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn test_opt(s:Option&lt;i32&gt;)&#123;</span><br><span class="line">    if let Some(x) = s&#123;  </span><br><span class="line">        println!(&quot;The number is: &#123;&#125;&quot;, x);  </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        println!(&quot;no number&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn test_match(s:Option&lt;i32&gt;)&#123;</span><br><span class="line">	match s&#123;</span><br><span class="line">		Some(val) =&gt; println!(&quot;The number is: &#123;&#125;&quot;, val),</span><br><span class="line">		None =&gt; println!(&quot;no number&quot;),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let some_number = Some(5);</span><br><span class="line">    let no_number: Option&lt;i32&gt; = None;</span><br><span class="line">    test_match(some_number);</span><br><span class="line">    test_opt(no_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result&lt;T,E&gt;"></a><code>Result&lt;T,E&gt;</code></h3><p><code>if let Ok(x) = s&#123;&#125; else if let Err(e) = s&#123;&#125;</code> double if &lt;T,E&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn div(a:i32,b:i32) -&gt; Result&lt;i32, String&gt;&#123;</span><br><span class="line">	if b == 0&#123;</span><br><span class="line">		Err(String::from(&quot;Error&quot;))</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		Ok(a/b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>if let<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">	let rel = div(10,2);</span><br><span class="line"></span><br><span class="line">	if let Ok(x) = rel&#123;</span><br><span class="line">		println!(&quot;result is &#123;&#125;&quot;,x);</span><br><span class="line">	&#125;else if let Err(e) = rel&#123;</span><br><span class="line">		println!(&quot;&#123;&#125;&quot;,e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>match<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">	let rel = div(10,2);</span><br><span class="line">	match rel &#123;</span><br><span class="line">		Ok(val) =&gt; println!(&quot;&#123;&#125;&quot;,val),</span><br><span class="line">		Err(e) =&gt; println!(&quot;&#123;&#125;&quot;,e),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a><code>enum</code></h3><p><code>if let Enumname::Onevaraint(T) = enum1&#123;&#125; else&#123;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Light &#123;</span><br><span class="line">    Red(String),</span><br><span class="line">    Yellow,</span><br><span class="line">    Green,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">	let l = Light::Red(String::from(&quot;Red light Stop&quot;));</span><br><span class="line">	if let Light::Red(t) = l&#123;</span><br><span class="line">		println!(&quot;&#123;&#125;&quot;,t);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		println!(&quot;Go or auction&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a><code>struct</code></h3><p><code>if let Structname&#123;x,y&#125; = p&#123; if x&gt;10&#123;&#125; &#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: u8,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p = Person &#123;</span><br><span class="line">        name: String::from(&quot;Alice&quot;),</span><br><span class="line">        age: 30,</span><br><span class="line">    &#125;;</span><br><span class="line">// Deconstruct + Guard condition</span><br><span class="line">   if let Person &#123; name, age &#125; = person &#123;</span><br><span class="line">        if age &gt; 18 &#123; //***</span><br><span class="line">            println!(&quot;&#123;&#125; is an adult.&quot;, name); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Nested-model"><a href="#Nested-model" class="headerlink" title="Nested model"></a>Nested model</h3><p><code>Enumname::A(Option&lt;T&gt;)</code><br><code>if let Enumname::A(opt) = a&#123; if Some(T) = opt&#123; fetch T&#125; &#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Action &#123;</span><br><span class="line">    Login(Option&lt;String&gt;),</span><br><span class="line">    Logout,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a = Action::Login(Some(String::from(&quot;Alice&quot;)));</span><br><span class="line">    </span><br><span class="line">    if let Action::Login(data) = a &#123; //if a is Action::Login(x)</span><br><span class="line">        if let Some(name) = data &#123; // if data is Option&lt;String&gt;</span><br><span class="line">            println!(&quot;User &#123;&#125; logged in&quot;, name); // </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(&quot;Guest logged in&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、while-let"><a href="#3、while-let" class="headerlink" title="3、while let"></a>3、while let</h2><p>Note: Continuous judgement</p>
<h3 id="Option-1"><a href="#Option-1" class="headerlink" title="Option"></a>Option</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut value = Some(3);</span><br><span class="line"></span><br><span class="line">    while let Some(x) = value &#123; // if value type is Some(T), do</span><br><span class="line">        if x &gt; 0 &#123;</span><br><span class="line">            println!(&quot;preaent value is &#123;&#125;&quot;, x);</span><br><span class="line">            value = Some(x - 1); // update</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            value = None; // end</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Go-through-vectors"><a href="#Go-through-vectors" class="headerlink" title="Go through vectors"></a>Go through vectors</h3><p><code>v.pop()</code> fetch the last num of the vector, return <code>Option(T)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">	let mut v = vec![1, 2, 3];  </span><br><span class="line">    while let Some(val) = stack.pop() &#123;</span><br><span class="line">        println!(&quot;Popped: &#123;&#125;&quot;, val);   </span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;Stack is empty.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>a = v.into_iter()</code> <code>a.next()</code> return <code>Option&lt;T&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut numbers: IntoIter&lt;i32&gt; = vec![10, 20, 30, 40, 50].into_iter();</span><br><span class="line"></span><br><span class="line">    while let Some(num) = numbers.next() &#123;</span><br><span class="line">        println!(&quot;num：&#123;&#125;&quot;, num);</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;iteration done&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Go-through"><a href="#Go-through" class="headerlink" title="Go through"></a>Go through</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum LinkedList &#123;</span><br><span class="line">    Node(i32, Box&lt;LinkedList&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use LinkedList::&#123;Node, Nil&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let list = Node(1, Box::new(Node(2, Box::new(Node(3, Box::new(Nil))))));</span><br><span class="line"></span><br><span class="line">    let mut current = &amp;list;</span><br><span class="line"></span><br><span class="line">    while let Node(value, next) = current &#123;</span><br><span class="line">        println!(&quot;节点值：&#123;&#125;&quot;, value);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;链表结束。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>E.g. : <strong>Type judgement</strong><br><code>&lt;T: Any&gt;</code> Accept any type  <code>TypeId::of::&lt;T&gt;()</code> Receive T</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::any::&#123;Any, TypeId&#125;;</span><br><span class="line">fn type_match&lt;T: Any&gt; (x: T) &#123;</span><br><span class="line">    match TypeId::of::&lt;T&gt;() &#123;</span><br><span class="line">        id if id == TypeId::of::&lt;String&gt;() =&gt; println!(&quot;String&quot;),</span><br><span class="line">        id if id == TypeId::of::&lt;i32&gt;() =&gt; println!(&quot;i32&quot;),</span><br><span class="line">        _ =&gt; 0, // 对于其他类型的情况</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>match</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay2 Rust Variales</title>
    <url>/2024/08/27/Rust-Day2/</url>
    <content><![CDATA[<h1 id="Rust-Variales"><a href="#Rust-Variales" class="headerlink" title="Rust Variales"></a>Rust Variales</h1><h2 id="1、Mutable-and-Immutable"><a href="#1、Mutable-and-Immutable" class="headerlink" title="1、Mutable and Immutable"></a>1、Mutable and Immutable</h2><p><strong>Declaration</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Immutable </span><br><span class="line">let x:i32 = 3;</span><br><span class="line">println!(&quot;The value of x is &#123;&#125;&quot;,x);</span><br></pre></td></tr></table></figure>
<p>Note: the valeue of x cannot be changed. <code>x = 1</code> <span style="color: red;">errror</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// mutable</span><br><span class="line">let mut y:i32 = 3;</span><br><span class="line">println!(&quot;The value of y is &#123;&#125;&quot;,y);</span><br><span class="line">y = 33;</span><br><span class="line">println!(&quot;The value of y is &#123;&#125;&quot;,y);</span><br></pre></td></tr></table></figure>

<h2 id="2、Constant"><a href="#2、Constant" class="headerlink" title="2、Constant"></a>2、Constant</h2><p><strong>Note</strong>:</p>
<ul>
<li>Data type must be specified.</li>
<li>Named with Uppercase letter.</li>
<li>Assigned value with constant expression.</li>
<li>Redefinition is not supported.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const N:i32 = 5;</span><br><span class="line">println!(&quot;The value of N is &#123;&#125;&quot;,N);</span><br><span class="line">const M:f32 = 0.75 * 25.0 / 100.0; //constant expression</span><br><span class="line">println!(&quot;The value of M is &#123;&#125;&quot;,M);</span><br></pre></td></tr></table></figure>
Note: the valeue of NUM cannot be changed. <code>NUM = 1</code> <span style="color: red;">errror</span></li>
</ul>
<p><strong>Note: The difference between Immutable &amp; Constant</strong></p>
<ul>
<li>Declaration method<ul>
<li>Constant–const+type+upper letter</li>
<li>Immutable–let</li>
</ul>
</li>
<li>Set period:<ul>
<li>Constant–Set during <strong>Compilation</strong>, cannot be changed during Runtime;</li>
<li>Immutable–Set during <strong>Runtime</strong>;</li>
</ul>
</li>
<li>Reset:<ul>
<li>Constant–NO</li>
<li>Immutable–Shadowing</li>
</ul>
</li>
</ul>
<h2 id="3、Static"><a href="#3、Static" class="headerlink" title="3、Static"></a>3、Static</h2><p>Note: </p>
<ul>
<li>Allocated memory during <strong>Compilation</strong>, exsit during Runtime.</li>
<li><strong>Shared</strong> in Whole Program and Threading.</li>
<li>Unchanged during Runtime, used for store <strong>Global status</strong>.</li>
</ul>
<p><strong>Note</strong>:<br><strong>The Similarity between Static &amp; Constant</strong></p>
<ul>
<li>Declaration method:<ul>
<li>const&#x2F;static+Type+Upper letter</li>
<li>Costant expression</li>
</ul>
</li>
<li>Reset:<ul>
<li>Shadowing( × )</li>
</ul>
</li>
</ul>
<p><strong>The Similarity between Static &amp; Constant</strong></p>
<ul>
<li>Inlining:<ul>
<li>Constant–Yes (lined and used in functions)</li>
<li>Static–No</li>
</ul>
</li>
<li>Reset:<ul>
<li>Constant–Unchanged</li>
<li>Static–Mut( √ ) this aspect similar to Mutable variable<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static S:i32 = 100; // Memory address 0x123</span><br><span class="line">static mut SM:i32 = 100; </span><br><span class="line">const C:i32 = 10;</span><br><span class="line"></span><br><span class="line">fn test()&#123;</span><br><span class="line">	unsafe&#123;</span><br><span class="line">		SM += 1;</span><br><span class="line">		println!(&quot;The value of SM is &#123;&#125;&quot;,SM);</span><br><span class="line">	&#125;//error:SM is Globle, mut-&gt;threading competing-&gt;unsafe</span><br><span class="line">//Inlink</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,C);</span><br><span class="line">	// Equal to: println!(&quot;&#123;&#125;&quot;,10) </span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,S);</span><br><span class="line">	// Equal to: println!(&quot;&#123;&#125;&quot;,&quot;0x123&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="4、Variable-Shadowing"><a href="#4、Variable-Shadowing" class="headerlink" title="4、Variable Shadowing"></a>4、Variable Shadowing</h2><p>Note:  <strong>Scope</strong> – Variable is binded to a sope, limited to <strong>live</strong> in a <strong>block</strong></p>
<ul>
<li><strong>Block</strong>: { xxx…… }, a variable outside a { } where it has been declared {note: outside, first layer}, is <strong>invalidate</strong>.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn binding()&#123;</span><br><span class="line">    let _a:i32 = 123;</span><br><span class="line">    &#123;</span><br><span class="line">        let _b:i32 = 321;</span><br><span class="line">        let _b:f32 = 456_f32; </span><br><span class="line">		    // Use shadow to Reset!!!--only Immutable</span><br><span class="line">        println!(&quot;B = &#123;&#125;&quot;,_b); //456</span><br><span class="line"></span><br><span class="line">        let _a:f32 = 789_f32;</span><br><span class="line">        println!(&quot;A = &#123;&#125;&quot;,_a); //789</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;A = &#123;&#125;&quot;,_a); //123</span><br><span class="line">   // println!(&quot;B = &#123;&#125;&quot;,_b); // [error: cannot find _b]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>variables</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay20 Macro</title>
    <url>/2024/09/10/Rust-Day20/</url>
    <content><![CDATA[<h2 id="Declarative-Macros"><a href="#Declarative-Macros" class="headerlink" title="Declarative Macros"></a>Declarative Macros</h2><p><strong><code>macro_rules! name &#123;&#125;</code></strong><br>INPUT: null<br>OUTPUT: execute <code>println!</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">macro_rules! say_hello &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        println!(&quot;Hello, world!&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    say_hello!(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Bsed on Match</strong><br>INPUT:</p>
<ul>
<li><code>ident</code>: match dentifiers and generate <strong>Functions or variables</strong> <ul>
<li><code>create_new!(foo); foo();</code></li>
</ul>
</li>
<li><code>expr</code>: match any <strong>Rust expressions</strong><ul>
<li><code>create_new!(2*3);</code></li>
</ul>
</li>
<li><code>$( ... ),*</code> : <strong>Repetition mode</strong>, divided by <code>,</code><br>OUTPUT:<br>(1)</li>
<li>return <code>fn $x()</code></li>
<li>stringify!&#96;: No compiling, just show String<br>(2)</li>
<li><code>$( ... )*</code> repetition mode</li>
<li><code>temp_vec.push($x)</code> Add expressions</li>
<li>return <code>vec!</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//lib.rs</span><br><span class="line">#[macro_export]</span><br><span class="line">macro_rules! create_new &#123;</span><br><span class="line">    </span><br><span class="line">    ($x: ident) =&gt; &#123;</span><br><span class="line">        fn $x() &#123;</span><br><span class="line">            println!(&quot;You called &#123;:?&#125;()!&quot;, stringify!($x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            let mut temp_vec = Vec::new();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.push($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    create_new!(foo);</span><br><span class="line">    create_new!(bar);</span><br><span class="line">    foo();</span><br><span class="line">    bar();</span><br><span class="line"></span><br><span class="line">    let v = create_new!(1, 2 + 3, if true &#123; 5 &#125; else &#123; 6 &#125;);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, v); // [1, 5, 5]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Procedural-Macros"><a href="#Procedural-Macros" class="headerlink" title="Procedural Macros"></a>Procedural Macros</h2><p>Define function in <code>crate</code></p>
<h3 id="Derive-Macros"><a href="#Derive-Macros" class="headerlink" title="Derive Macros"></a>Derive Macros</h3><pre><code>`#[derive(...)]`
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/parent_directory/</span><br><span class="line">├── my_proc_macro/</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src/</span><br><span class="line">│       └── lib.rs</span><br><span class="line">└── my_project/</span><br><span class="line">    ├── Cargo.toml</span><br><span class="line">    └── src/</span><br><span class="line">        └── main.rs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(1) <code>cargo new my_derive --lib</code>  <code>cargo new my_project</code><br>(2) <code>my_proc_macro.toml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">syn = &quot;2.0.77&quot;        # a library for parsing AST of rust code</span><br><span class="line">quote = &quot;1.0&quot;      # generate rust code</span><br><span class="line">proc-macro2 = &quot;1.0&quot; # process proc_macros tools</span><br><span class="line"></span><br><span class="line">[lib]</span><br><span class="line">proc-macro = true</span><br></pre></td></tr></table></figure>
<p>(3)<code>lib.rs</code></p>
<p>Note:<br><code>TokenStream</code>-&gt;<code>AST</code>-&gt;code</p>
<ul>
<li><p><code>#[my_macro_name(funtion_name)]</code></p>
</li>
<li><p><code>syn::parse().unwrap()</code></p>
<ul>
<li><code>syn::parse()</code> :<code>TokenStream</code> -&gt;AST</li>
<li><code>unwrap()</code>: fetch x from <code>Result/Option</code></li>
</ul>
</li>
<li><p><code>syn::DeriveInput</code>: <code>#[derive]&#39;s input</code>–<code>#[derive]</code> 修饰的struct或enum</p>
</li>
<li><p><code>ast.ident</code>: Struct Name</p>
</li>
<li><p><code>quote!</code>: AST-&gt;code</p>
<ul>
<li><code>impl #name</code>: in quate, <code>insert</code> programmar, <code>#name</code>-&gt;<code>struct/enum...</code></li>
</ul>
</li>
<li><p><code>gen.into()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern crate proc_macro;</span><br><span class="line"></span><br><span class="line">use proc_macro::TokenStream;</span><br><span class="line">use quote::quote;</span><br><span class="line">use syn;</span><br><span class="line"></span><br><span class="line">#[proc_macro_derive(HelloWorld)]</span><br><span class="line"></span><br><span class="line">//public fn</span><br><span class="line">pub fn hello_world_derive(x: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">   </span><br><span class="line">    let ast = syn::parse(x).unwrap();</span><br><span class="line">    </span><br><span class="line">    impl_hello_world(&amp;ast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// private fn</span><br><span class="line">fn impl_hello_world(ast: &amp;syn::DeriveInput) -&gt; TokenStream &#123;</span><br><span class="line">    let name = &amp;ast.ident;</span><br><span class="line">    let gen = quote! &#123;</span><br><span class="line">        impl #name &#123;</span><br><span class="line">            pub fn hello_world() &#123;</span><br><span class="line">                println!(&quot;Hello, World! My name is &#123;&#125;!&quot;, stringify!(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.into()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>(4)<code>my_project</code> <code>cargo.toml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">my_proc_macro = &#123; path = &quot;../my_proc_macro&quot; &#125;</span><br></pre></td></tr></table></figure>

<p>(5)<code>main.rs</code></p>
<ul>
<li><code>use my_macro_name::funtion_name</code></li>
<li><code>#[derive(function_name)]</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use my_proc_macro::HelloWorld;</span><br><span class="line"></span><br><span class="line">#[derive(HelloWorld)]</span><br><span class="line">struct MyStruct;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    MyStruct::hello_world();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Attribute-Macros"><a href="#Attribute-Macros" class="headerlink" title="Attribute Macros"></a>Attribute Macros</h3><p><code>#[derive(Debug, Clone, PartialEq)]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#[derive(Debug, Clone, PartialEq)]</span><br><span class="line">struct Person &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: u32,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p1 = Person &#123; name: &quot;Alice&quot;.to_string(), age: 30 &#125;;</span><br><span class="line">    let p2 = p1.clone(); //Clone trait</span><br><span class="line">    </span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, p1); // Debug trait</span><br><span class="line">    println!(&quot;Are they equal? &#123;&#125;&quot;, p1 == p2); // PartialEq trait</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#[cfg]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#[cfg(feature = &quot;foo&quot;)]</span><br><span class="line">fn foo() &#123;</span><br><span class="line">    println!(&quot;Feature foo is enabled&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(not(feature = &quot;foo&quot;))]</span><br><span class="line">fn foo() &#123;</span><br><span class="line">    println!(&quot;Feature foo is not enabled&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    foo(); //Feature foo is not enabled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li></li>
<li><code>#[macro_export]</code>: <code>lib.rs</code> define -&gt; export<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// lib.rs </span><br><span class="line">#[macro_export]</span><br><span class="line">macro_rules! say_hello &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        println!(&quot;Hello!&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main.rs</span><br><span class="line">use my_macro_crate::say_hello;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    say_hello!(); // Hello！</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Function-Macros"><a href="#Function-Macros" class="headerlink" title="Function Macros"></a>Function Macros</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let message = format!(&quot;Hello, &#123;&#125;!&quot;, &quot;world&quot;);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>debug_assert!()</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 10;</span><br><span class="line">    debug_assert!(x == 10, &quot;x should be 10&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>assert_eq()</code>  <code>assert_ne()</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = 5;</span><br><span class="line">    let b = 5;</span><br><span class="line">    assert_eq!(a, b, &quot;a should equal b&quot;);</span><br><span class="line">    </span><br><span class="line">    let x = 10;</span><br><span class="line">    let y = 20;</span><br><span class="line">    assert_ne!(x, y, &quot;x should not equal y&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>vec![]</code></li>
<li><code>macro_rules!</code></li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Macros</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay17&amp;18&amp;19 Generics &amp; Trait &amp; Closure</title>
    <url>/2024/09/08/Rust-Day17%20&amp;%20Day18%20&amp;%20Day19/</url>
    <content><![CDATA[<h2 id="Generics：T"><a href="#Generics：T" class="headerlink" title="Generics：T"></a>Generics：T</h2><h3 id="T–-parameters"><a href="#T–-parameters" class="headerlink" title="T–&gt; parameters"></a>T–&gt; parameters</h3><ul>
<li><code>fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T</code><ul>
<li><code>&lt;T: PartialOrd&gt;</code>: <code>PartialOrd</code> trait– support compairision</li>
<li>input: <code>&amp;[T]</code> : <code>&amp;Vec&lt;i32&gt; &amp;Vec&lt;char&gt;</code>…</li>
<li>output: <code>&amp;T</code> :<code>&amp;i32  &amp;char</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T &#123;</span><br><span class="line">    let mut largest: &amp;T = &amp;list[0]; </span><br><span class="line">    for item:&amp;T in list.iter() &#123;</span><br><span class="line">        if item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let numbers = vec![1, 2, 3, 4, 5];</span><br><span class="line">    let result: &amp;i32 = largest(&amp;numbers); //T-i32</span><br><span class="line">    println!(&quot;The largest number is &#123;&#125;&quot;, result);</span><br><span class="line"></span><br><span class="line">    let chars = vec![&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;];</span><br><span class="line">    let result: &amp;char = largest(&amp;chars);// T-char</span><br><span class="line">    println!(&quot;The largest char is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="T–-Struct-variants"><a href="#T–-Struct-variants" class="headerlink" title="T–&gt; Struct variants"></a>T–&gt; Struct variants</h3><ul>
<li><code>struct Struct_name&lt;T&gt;</code><ul>
<li><code>struct Name&lt;T&gt;&#123;x:t,y:T,&#125;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let int_point = Point &#123; x: 5, y: 10 &#125;;</span><br><span class="line">    let float_point = Point &#123; x: 1.0, y: 4.0 &#125;;</span><br><span class="line">    println!(&quot;int_point: (&#123;&#125;, &#123;&#125;)&quot;, int_point.x, int_point.y);</span><br><span class="line">    println!(&quot;float_point: (&#123;&#125;, &#123;&#125;)&quot;, float_point.x, float_point.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>struct Struct_name&lt;T, U&gt;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Point&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mixed_point = Point &#123; x: 5, y: 4.5 &#125;;</span><br><span class="line">    println!(&quot;mixed_point: (&#123;&#125;, &#123;&#125;)&quot;, mixed_point.x, mixed_point.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="T–-Enum"><a href="#T–-Enum" class="headerlink" title="T–&gt; Enum"></a>T–&gt; Enum</h3><ul>
<li><code>Option&lt;T&gt;&#123;Some(T),None&#125;</code> </li>
<li><code>Result&lt;T,E&gt;&#123;Ok(T),Err(E)&#125;</code></li>
</ul>
<h2 id="T-Trait"><a href="#T-Trait" class="headerlink" title="T + Trait"></a>T + Trait</h2><h3 id="T–-trait"><a href="#T–-trait" class="headerlink" title="T–&gt;trait"></a>T–&gt;trait</h3><ul>
<li><code>impl&lt;T&gt; trait_name&lt;T&gt; for Struct_name&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Struct_name&lt;T&gt;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line">trait Return_point&lt;T&gt;&#123;</span><br><span class="line">    fn return_p( &amp;self )-&gt;&amp;T;</span><br><span class="line">&#125;</span><br><span class="line">impl&lt;T&gt; Return_point&lt;T&gt; for Point&lt;T&gt; &#123;</span><br><span class="line">    fn return_p( &amp;self ) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;self.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p = Point &#123; x: 5, y: 10 &#125;;</span><br><span class="line">    println!(&quot;p.x = &#123;&#125;&quot;, p.return_p());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Where-Define-the-type-of"><a href="#Where-Define-the-type-of" class="headerlink" title="Where : Define the type of &lt;T,E&gt;"></a>Where : Define the type of <code>&lt;T,E&gt;</code></h3><p><code>T:PartialOrd + Display + Clone...</code><br>① Function<br><code>fn fun_a&lt;T: A+B,F:A+B&gt;(a:T,b:F) -&gt; (&amp;T,&amp;F)&#123;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::fmt::Display; </span><br><span class="line"></span><br><span class="line">fn compare_and_print&lt;T: PartialOrd + Display&gt;(a: T, b: T) &#123; </span><br><span class="line">	if a &gt; b &#123; </span><br><span class="line">		println!(&quot;&#123;&#125; is larger than &#123;&#125;&quot;, a, b); </span><br><span class="line">	&#125; else &#123; </span><br><span class="line">		println!(&quot;&#123;&#125; is larger than &#123;&#125;&quot;, b, a); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line">fn main() &#123; </span><br><span class="line">	compare_and_print(5, 10); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② Trait<br><code>trait Trait_name&lt;T&gt; where T : Clone + PartialEq,&#123; &#125;</code> </p>
<ul>
<li>trait<ul>
<li><code>self -&gt; struct</code>, <code>self.0 -&gt; Vec&lt;T&gt;</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trait Container_fun&lt;T&gt;</span><br><span class="line">where</span><br><span class="line">    T: Clone,</span><br><span class="line">&#123;</span><br><span class="line">    fn contains(&amp;self, item: &amp;T) -&gt; bool;</span><br><span class="line">    fn add(&amp;mut self, item: T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct VecContainer&lt;T&gt;(Vec&lt;T&gt;);</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Container_fun&lt;T&gt; for VecContainer&lt;T&gt;</span><br><span class="line">where</span><br><span class="line">    T: Clone + PartialEq,</span><br><span class="line">&#123;</span><br><span class="line">    fn contains(&amp;self, item: &amp;T) -&gt; bool &#123;</span><br><span class="line">        self.0.contains(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add(&amp;mut self, item: T) &#123;</span><br><span class="line">        self.0.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
③ Struct<br><code>struct Struct_name&lt;T&gt; where T: A+B,&#123;&#125;</code> <code>impl&lt;T&gt; struct_name&lt;T&gt;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::fmt::Display;</span><br><span class="line"></span><br><span class="line">struct Pair&lt;T&gt;</span><br><span class="line">where</span><br><span class="line">    T: Display + PartialOrd,</span><br><span class="line">&#123;</span><br><span class="line">    first: T,</span><br><span class="line">    second: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Pair&lt;T&gt;</span><br><span class="line">where</span><br><span class="line">    T: Display + PartialOrd,</span><br><span class="line">&#123;</span><br><span class="line">    fn new(first: T, second: T) -&gt; Self &#123;</span><br><span class="line">        Pair &#123; first, second &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn cmp_display(&amp;self) &#123;</span><br><span class="line">        if self.first &gt; self.second &#123;</span><br><span class="line">            println!(&quot;The largest member is &#123;&#125;&quot;, self.first);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(&quot;The largest member is &#123;&#125;&quot;, self.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let pair = Pair::new(5, 10);</span><br><span class="line">    pair.cmp_display();</span><br><span class="line"></span><br><span class="line">    let float_pair = Pair::new(1.2, 3.4);</span><br><span class="line">    float_pair.cmp_display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
④ related type<br><code>T: A, T::Item: B+C,</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::fmt::Display;</span><br><span class="line"></span><br><span class="line">fn modify_iter&lt;T&gt;(v: T) -&gt; impl Iterator&lt;Item = T::Item&gt;</span><br><span class="line">where</span><br><span class="line">    T: Iterator,</span><br><span class="line">    T::Item: Display + std::ops::Add&lt;i32, Output = T::Item&gt; + Copy,</span><br><span class="line">&#123;</span><br><span class="line">    v.map(|x| &#123;</span><br><span class="line">        let new_value = x + 1;</span><br><span class="line">        new_value</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![1, 2, 3];</span><br><span class="line">    let new_iter = modify_iter(v.into_iter());</span><br><span class="line">    for item in new_iter &#123;</span><br><span class="line">        println!(&quot;Processed: &#123;&#125;&quot;, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><h3 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h3><p>A <strong>Struct</strong> realizing a specialized <strong>trait</strong></p>
<ul>
<li><strong>Anonymity</strong>: × name, can be defined and used directly <strong>inline</strong>.</li>
<li>Use <strong>variables</strong> that are in scope at the time of definition.</li>
<li>can accept <strong>parameters</strong> like a normal function.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|parameter1, parameter2, ...| -&gt; return_type &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let add = |a, b| a + b;</span><br><span class="line">println!(&quot;Sum: &#123;&#125;&quot;, add(5, 3)); </span><br></pre></td></tr></table></figure>
<h3 id="Capture-variables"><a href="#Capture-variables" class="headerlink" title="Capture variables"></a>Capture variables</h3><ul>
<li>Borrow <code>&amp;</code></li>
<li>Mut Borrow <code>&amp;mut</code></li>
<li>Ownership transfer <code>let x1 = move || x</code></li>
<li><code>impl Fn() -&gt; return_type</code> : unchange captured v</li>
<li><code>impl FnMut() -&gt; return_type</code>: change captured v</li>
<li><code>move ||&#123;&#125;</code>: Consume captured v<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">	// Borrow Fn</span><br><span class="line">    let x = 5;</span><br><span class="line">    let print_x: impl Fn()  = || println!(&quot;x is: &#123;&#125;&quot;, x);  </span><br><span class="line">    print_x();</span><br><span class="line">    </span><br><span class="line">   // Mut Borrow FnMut</span><br><span class="line">    let mut y = 5;</span><br><span class="line">    let mut add_y: impl FnMut(i32) -&gt; i32 = |a: i32| &#123; y += a; y &#125;;  </span><br><span class="line">    println!(&quot;y is &#123;&#125;&quot;,add_y(2));</span><br><span class="line"></span><br><span class="line">	// Ownership FnOnce</span><br><span class="line">    let z = 5;</span><br><span class="line">    let own_z: impl Fn() -&gt; i32 = move || z;  </span><br><span class="line">    let zz = own_z();</span><br><span class="line">    println!(&quot;zz is &#123;&#125;&quot;,zz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
E.g.:</li>
<li><code>fn fn_immut&lt;T, F&gt;(val: T, f: F) -&gt; T)</code><ul>
<li><code>Where F: Fn()-&gt;T</code> <strong>restriction on F</strong></li>
<li><code>&#123; let _ = f(); val &#125;</code>: Call <code>f: Fn()</code> return <code>val:T</code></li>
</ul>
</li>
<li><code>f:Fn() = | |&#123;&#125;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn fn_immut&lt;T, F&gt;(val: T, f: F) -&gt; T</span><br><span class="line">where</span><br><span class="line">    F: Fn() -&gt; T,</span><br><span class="line">&#123;</span><br><span class="line">    let _ = f(); </span><br><span class="line">    val </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 10;</span><br><span class="line">    let xx:i32 = fn_immut(x, || &#123;</span><br><span class="line"></span><br><span class="line">        println!(&quot;Fn: x is &#123;&#125;&quot;, x);</span><br><span class="line">        x</span><br><span class="line">    &#125;);</span><br><span class="line">    println!(&quot;xx is &#123;&#125;&quot;, xx); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Generics</tag>
        <tag>Closure</tag>
        <tag>trait</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay22 lib.rs</title>
    <url>/2024/09/11/Rust-Day22/</url>
    <content><![CDATA[<p><code>cargo new --lib libname</code></p>
<h2 id="Delcaration"><a href="#Delcaration" class="headerlink" title="Delcaration"></a>Delcaration</h2><ul>
<li>declare module: <code>pub mod name;</code></li>
<li>declare function: <code>pub fn hello()-&gt;String&#123;String::from(&quot;Hello&quot;)&#125;;</code></li>
<li>struct: <code>pub struct Person&#123;pub x:i32,pub y:String,&#125;</code></li>
<li>impl: <code>impl Person&#123; pun fn great()&#123;&#125;&#125;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// src/lib.rs</span><br><span class="line"></span><br><span class="line">pub struct Person&#123;&#125;;</span><br><span class="line">pub mod shapes;</span><br><span class="line"></span><br><span class="line">pub fn greet() -&gt; String &#123;</span><br><span class="line">    String::from(&quot;Hello from the library!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><h3 id="set-up-project"><a href="#set-up-project" class="headerlink" title="set up project"></a>set up project</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_project/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── lib.rs         // lib</span><br><span class="line">│   ├── math.rs        // external mod math</span><br><span class="line">│   └── shapes/        // external mod shapes</span><br><span class="line">│       ├── mod.rs     // entrance of shapes mod </span><br><span class="line">│       ├── circle.rs   </span><br><span class="line">│       └── square.rs  </span><br><span class="line">└── Cargo.toml        </span><br></pre></td></tr></table></figure>
<h3 id="Realisation"><a href="#Realisation" class="headerlink" title="Realisation"></a>Realisation</h3><ul>
<li><p><code>lib.rs</code>  note: default–private</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mod math;</span><br><span class="line">mod shapes;</span><br><span class="line">// public function</span><br><span class="line">pub fn area_of_square(side: f64) -&gt; f64 &#123;</span><br><span class="line">    shapes::square::area(side)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>math.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pub fn add(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// private</span><br><span class="line">fn subtract(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>use</code><br><code>use math::add</code>  <code>use math::*</code> note: all <code>pub</code> function<br><code>lib.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mod math;</span><br><span class="line">use math::add;</span><br><span class="line"></span><br><span class="line">pub fn calculate_sum(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    add(a, b)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>shapes/mod.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pub mod circle;  </span><br><span class="line">pub mod square; </span><br></pre></td></tr></table></figure></li>
<li><p><code>circle.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PI: f64 = 3.14159;</span><br><span class="line">pub fn area(radius: f64) -&gt; f64 &#123;</span><br><span class="line">    PI * radius * radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>square.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pub fn area(side: f64) -&gt; f64 &#123;</span><br><span class="line">    side * side</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>use</code><br><code>lib.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use shapes::circle::*</span><br><span class="line">mod shapes;</span><br><span class="line">pub fn circle_area(radius: f64) -&gt; f64 &#123;</span><br><span class="line">    area(radius)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Relation:</p>
<ul>
<li><strong>father call son mod:</strong> <code>lib.rs</code> - <code>math::add</code>  <code>shapes::circle::area</code></li>
<li><strong>son call father mod</strong>: <ul>
<li><code>use crate::math::add</code> note:<code>crate</code> - root mod <code>lib.rs</code></li>
<li><code>use super::*</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// src/shapes/circle.rs</span><br><span class="line">use crate::math::add; </span><br><span class="line"></span><br><span class="line">pub fn area_with_add(radius: f64) -&gt; f64 &#123;</span><br><span class="line">    add(radius as i32, radius as i32) as f64 * 3.14159</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h2><h3 id="internal-lib-same-project"><a href="#internal-lib-same-project" class="headerlink" title="internal lib (same project)"></a>internal lib (same project)</h3><h4 id="integrated-test"><a href="#integrated-test" class="headerlink" title="integrated test"></a>integrated test</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_project/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── lib.rs         </span><br><span class="line">│   ├── math.rs        </span><br><span class="line">│   └── shapes/        </span><br><span class="line">│       ├── mod.rs      </span><br><span class="line">│       ├── circle.rs   </span><br><span class="line">│       └── square.rs  </span><br><span class="line">├── tests/</span><br><span class="line">│   └── test.rs</span><br><span class="line">└── Cargo.toml </span><br></pre></td></tr></table></figure>

<ul>
<li><code>use my_libtest::&#123;mod1,fun1&#125;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// test.rs</span><br><span class="line">use my_libtest::&#123;greet, math&#125;;</span><br><span class="line"></span><br><span class="line">#[test]</span><br><span class="line">fn test_greet() &#123;</span><br><span class="line">    let greeting = greet();</span><br><span class="line">    assert_eq!(greeting, &quot;Hello from the library!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[test]</span><br><span class="line">fn test_add() &#123;</span><br><span class="line">    let sum = math::add(2, 3);</span><br><span class="line">    assert_eq!(sum, 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="cfg-test"><a href="#cfg-test" class="headerlink" title="#[cfg(test)]"></a><code>#[cfg(test)]</code></h4><ul>
<li><code>#[cfg(test)]</code>: only compile while testing  <ul>
<li><code>#[test]</code>: no parameter; no return  – <code>cargo test</code>  or <code>cargo test name</code></li>
<li><code>#[should_panic!(expected = &quot;This will panic!&quot;)]</code>: panic will be triggered</li>
<li><code>#[ignore]</code>  – <code>cargo test -- --ignored</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// lib.rs</span><br><span class="line">#[cfg(test)]</span><br><span class="line"></span><br><span class="line">mod tests &#123;</span><br><span class="line">    fn test()&#123;</span><br><span class="line">        println!(&quot;Hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_works() &#123;</span><br><span class="line">        test();</span><br><span class="line">        assert_eq!(2 + 2, 4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>common assertion macro<br><code>assert!(condition)</code><br><code>assert_eq!(a,b)</code><br><code>assert_ne!(a,b)</code><br><code>panic!()</code></li>
</ul>
<h3 id="external-lib-different-project"><a href="#external-lib-different-project" class="headerlink" title="external lib (different project)"></a>external lib (different project)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_project/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── lib.rs         </span><br><span class="line">│   ├── math.rs        </span><br><span class="line">│   └── shapes/        </span><br><span class="line">│       ├── mod.rs      </span><br><span class="line">│       ├── circle.rs   </span><br><span class="line">│       └── square.rs  </span><br><span class="line">├── tests/</span><br><span class="line">│   └── test.rs</span><br><span class="line">├── Cargo.toml </span><br><span class="line">my_project/</span><br><span class="line">├── src/</span><br><span class="line">│   └── main.rs</span><br><span class="line">└── Cargo.toml</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>my_project/Cargo.toml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[dependencies] my_library = &#123; path = &quot;../my_library&quot; &#125; </span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">my_library = &#123; git = &quot;https://github.com/username/my_library.git&quot;, branch = &quot;main&quot; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>main.rs</code></p>
<ul>
<li><code>use my_libtest::math::*</code></li>
<li><code>use my_libtest::great</code></li>
<li><code>use my_libtest::shape::circle::*</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// src/main.rs</span><br><span class="line">use my_libtest::greet;</span><br><span class="line">use my_libtest::math;</span><br><span class="line">use my_libtest::shapes::circle::*;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let greeting = greet();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, greeting);</span><br><span class="line">  </span><br><span class="line">    let sum = math::add(5, 3);</span><br><span class="line">    println!(&quot;5 + 3 = &#123;&#125;&quot;, sum);</span><br><span class="line">  </span><br><span class="line">    let a = circle_area(3.0);</span><br><span class="line">    println!(&quot;area&#123;&#125;&quot;,a as i32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Module</tag>
        <tag>test</tag>
        <tag>macro</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay21 Iterators and Associative Types</title>
    <url>/2024/09/11/Rust-Day21/</url>
    <content><![CDATA[<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h2><ul>
<li><strong>Next</strong><ul>
<li><code>let nums: IntoIter&lt;i32&gt; = v.into_iter();</code></li>
<li><code>let num: Option&lt;T&gt; = nums.next();</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mut numbers = vec![1, 2, 3].into_iter();</span><br><span class="line">assert_eq!(numbers.next(), Some(1));</span><br><span class="line">assert_eq!(numbers.next(), Some(2));</span><br><span class="line">assert_eq!(numbers.next(), Some(3));</span><br><span class="line">assert_eq!(numbers.next(), None);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>map</strong><ul>
<li><code>let vv: Vec&lt;i32&gt; = v.into_iter().map(|x| fx).collect();</code></li>
<li><code>map</code> operate on <code>Iter</code> return <code>New Iter</code></li>
<li><code>collect</code>: <code>Iter</code> -&gt; <code>Vec</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let numbers = vec![1, 2, 3];</span><br><span class="line">let doubled: Vec&lt;i32&gt; = numbers.into_iter().map(|x| x * 2).collect();</span><br><span class="line">assert_eq!(doubled, vec![2, 4, 6]);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>filter</strong><ul>
<li><code>let vv: Vec&lt;i32&gt; = v.into_iter().filer(|x| fx == n).collect();</code></li>
<li><code>filter</code> operate on <code>Iter</code> return <code>New Iter</code></li>
<li><code>collect</code>: <code>Iter</code> -&gt; <code>Vec</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let numbers = vec![1, 2, 3, 4, 5];</span><br><span class="line">let even_numbers: Vec&lt;i32&gt; = numbers.into_iter().filter(|x| x % 2 == 0).collect();</span><br><span class="line">assert_eq!(even_numbers, vec![2, 4]);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>Customized</strong><ul>
<li><code>fn new()</code> </li>
<li><code>fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;&#123;&#125;</code><ul>
<li><code>Self::Item</code> : struct variants</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Counter &#123;</span><br><span class="line">    count: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Counter &#123;</span><br><span class="line">    fn new() -&gt; Counter &#123;</span><br><span class="line">        Counter &#123; count: 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Iterator for Counter &#123;</span><br><span class="line">    type Item = u32;</span><br><span class="line"></span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="line">        self.count += 1;</span><br><span class="line">        if self.count &lt;= 5 &#123;</span><br><span class="line">            Some(self.count)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            None</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut counter = Counter::new();</span><br><span class="line">    assert_eq!(counter.next(), Some(1));</span><br><span class="line">    assert_eq!(counter.next(), Some(2));</span><br><span class="line">    assert_eq!(counter.next(), Some(3));</span><br><span class="line">    assert_eq!(counter.next(), Some(4));</span><br><span class="line">    assert_eq!(counter.next(), Some(5));</span><br><span class="line">    assert_eq!(counter.next(), None);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h2><p><code>trait Trait_name&#123; type Item;  return Self::Item&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trait Iterator &#123;</span><br><span class="line">    type Item;    </span><br><span class="line">    fn my_method(&amp;self) -&gt; Self::Item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MyIterator &#123;</span><br><span class="line">    value: i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl IteratorExt for MyIterator &#123;</span><br><span class="line">    type Item = i32;</span><br><span class="line"></span><br><span class="line">    fn my_method(&amp;self) -&gt; Self::Item &#123;</span><br><span class="line">        self.value * 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let iter = MyIterator &#123; value: 10 &#125;;</span><br><span class="line">    assert_eq!(iter.my_method(), 20);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Iterator</tag>
        <tag>Associative Types</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay3&amp;4 Function &amp; Process control</title>
    <url>/2024/08/27/Rust-Day3%20&amp;%20Day4/</url>
    <content><![CDATA[<h2 id="1、Function"><a href="#1、Function" class="headerlink" title="1、Function"></a>1、Function</h2><h3 id="①-Normal-function"><a href="#①-Normal-function" class="headerlink" title="① Normal function"></a>① Normal function</h3><p>Note：</p>
<ul>
<li>Snake case: <code>f()-&gt;x</code></li>
<li><code>return x+y;</code> or <code>x+y</code></li>
<li>A data <strong>type</strong> is necessary<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn add(x:i32,y:i32)-&gt; i32&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">fn add()-&gt;()&#123; //return null</span><br><span class="line">	println!(&quot;Love&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="②-Diverge-function-Never-Return"><a href="#②-Diverge-function-Never-Return" class="headerlink" title="② Diverge function (Never Return)"></a>② Diverge function (Never Return)</h3><p>Note: <code>!</code> means no return</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn deadend() -&gt; ! &#123;</span><br><span class="line">	panic!(&quot;You&#x27;re done&quot;);</span><br><span class="line">	loop&#123;&#125;;</span><br><span class="line">	todo!();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、Process-control"><a href="#2、Process-control" class="headerlink" title="2、Process control"></a>2、Process control</h2><h3 id="①-IF"><a href="#①-IF" class="headerlink" title="① IF"></a>① IF</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if number &lt; 5 &#123;</span><br><span class="line">	println!(&quot;True&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if number ==5 &#123;</span><br><span class="line">	println!(&quot;Exact&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	println!(&quot;Wrong&quot;);</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h3 id="②-Loop"><a href="#②-Loop" class="headerlink" title="② Loop"></a>② Loop</h3><p>Note:</p>
<ul>
<li>loop{} </li>
<li><strong>continue</strong> : Jump back to the first line in the loop</li>
<li><strong>break</strong> : Jump out the loopmm ( only jump out one layer loop )<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">	let num = 0;</span><br><span class="line">	loop &#123;</span><br><span class="line">		num +=1;</span><br><span class="line">		if num == 3 &#123;</span><br><span class="line">			println!(&quot;I don&#x27;t like 3&quot;);</span><br><span class="line">			continue; </span><br><span class="line">		&#125;</span><br><span class="line">		println!(&quot;&#123;&#125;&quot;,num);</span><br><span class="line">		if num &gt; 5 &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Muti-layer loop</li>
</ul>
<p><code>&#39;name: loop&#123;&#125;</code>  <code>break &#39;name;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mut a = 10;</span><br><span class="line">&#x27;layer1: loop &#123;</span><br><span class="line">	a += 1;</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,a);</span><br><span class="line">    loop&#123;</span><br><span class="line">	    a -= 1;</span><br><span class="line">		 if a &lt; 5&#123;</span><br><span class="line">			println!(&quot;&#123;&#125;&quot;,a);</span><br><span class="line">			break &#x27;layer1;</span><br><span class="line">		&#125;                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="③-While"><a href="#③-While" class="headerlink" title="③ While"></a>③ While</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = [&quot;I&quot;,&quot;Love&quot;,&quot;YOU&quot;];</span><br><span class="line">let mut i = 0;</span><br><span class="line">while i &lt; a.len()&#123;</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="④-For"><a href="#④-For" class="headerlink" title="④ For"></a>④ For</h3><p> Note: </p>
<ul>
<li><code>(0..3) 0 1 2</code> <code>(0..=3) 0 1 2 3</code> <code>(0..3).rev() 2 1 0</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = [&quot;I&quot;,&quot;Love&quot;,&quot;YOU&quot;];</span><br><span class="line">let b = [&quot;zhang&quot;,&quot;ruo&quot;,&quot;yun&quot;];</span><br><span class="line">for i in a &#123; </span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,i);</span><br><span class="line">&#125;</span><br><span class="line">for i in (0..3)&#123;</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,b[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="⑤-Iterate-over-arrays"><a href="#⑤-Iterate-over-arrays" class="headerlink" title="⑤ Iterate over arrays"></a>⑤ Iterate over arrays</h3><h4 id="iter-Go-through-array"><a href="#iter-Go-through-array" class="headerlink" title=".iter()   Go through array"></a><code>.iter()</code>   Go through array</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x: [&amp;str;3] = [&quot;道&quot;,&quot;可&quot;,&quot;道&quot;]; </span><br><span class="line">for i: &amp;&amp;str in x.iter()&#123;</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>.iter().map().collect()</code> Pose f(x) to x in X–&gt;Y<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = [1, 2, 3, 4, 5];    </span><br><span class="line">    let y: Vec&lt;i32&gt; = x.iter().map(|x| x * 2-1).collect();</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, y); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>iter().enumerate()</code> Index and value iterate togather<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let names = [&quot;道可道&quot;, &quot;非常道&quot;, &quot;无名&quot;, &quot;天地之始&quot;];</span><br><span class="line">	for (index, name) in names.iter().enumerate() &#123;</span><br><span class="line">        println!(&quot;Index: &#123;&#125;, Value: &#123;&#125;&quot;, index, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
&#96;&#96;<br>Note: <strong>Integer array</strong>  Copy only</li>
</ul>
<h3 id="⑥-Call-to-Assign"><a href="#⑥-Call-to-Assign" class="headerlink" title="⑥ Call to Assign"></a>⑥ Call to Assign</h3><ul>
<li><strong>Call if</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let condition = true;</span><br><span class="line">let number = if condition &#123;</span><br><span class="line">	5</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">	6</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>Call loop</strong><br>Note: The return is determined by <strong>break</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mut counter = 10;</span><br><span class="line">let num = loop &#123;</span><br><span class="line">	counter += 1;</span><br><span class="line">	if counter &gt; 10 &#123;</span><br><span class="line">		break counter * 2;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">println!(&quot;&#123;&#125;&quot;,num);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay20 Cocurrency and shared data</title>
    <url>/2024/09/12/Rust-Day23/</url>
    <content><![CDATA[<h2 id="conscept"><a href="#conscept" class="headerlink" title="conscept"></a>conscept</h2><p>Cocurrency: multi-tasks, no need execute at the same time (e.g. multi-threaded)<br>Parallelism: multi-tasks, simultaneous execute , occurring on multi-core CPUs.<br>    Rust’s concurrency model:</p>
<ul>
<li>threads</li>
<li>asynchronous programming (async&#x2F;await),</li>
<li>message passing</li>
<li>shared state</li>
</ul>
<h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><p><code>std::thread</code><br>    Each thread is a separate unit of execution, run on different cores.<br>    <code>thread::spawn()</code>: create new thread, reveive a closure<br>    <code>thread::sleep()</code>: pause for Duration<br>    <code>Duration::from_millis()</code>  &#96;Duration::from_secs()<br>main thread i&#x3D;1 pause(1ms) -&gt; sub thread i&#x3D;1 (1ms) -&gt; …-&gt;main thread finished join()<br>-&gt;  sub thread</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let handle = thread::spawn(|| &#123;  // sub thread</span><br><span class="line">        for i in 1..10 &#123;</span><br><span class="line">            println!(&quot;Thread: &#123;&#125;&quot;, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for i in 1..5 &#123; //main thread</span><br><span class="line">        println!(&quot;Main thread: &#123;&#125;&quot;, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();// wait for sub-thread</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Message-passing-between-thread"><a href="#Message-passing-between-thread" class="headerlink" title="Message passing (between thread)"></a>Message passing (between thread)</h2><ul>
<li><code>mpsc::channel</code>: create a channel, return<code>tx</code>(sender)、<code>rx</code>(receiver)</li>
<li><code>tx.send(T).unwrap()</code> <code>tx.recv().unwrap()</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::sync::mpsc;</span><br><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(move || &#123; //sub thread</span><br><span class="line">        let val = String::from(&quot;Hello from thread!&quot;);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">        thread::sleep(Duration::from_secs(1));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let received = rx.recv().unwrap(); // main thread</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="shared-state"><a href="#shared-state" class="headerlink" title="shared state"></a>shared state</h2><p><code>Arc&lt;T&gt;</code>:  &amp;counter  Immutable</p>
<ul>
<li><code>counter = Arc::new(T)</code>: a value could be shared between threads</li>
<li><code>Arc::strong_count(&amp;counter)</code>: sub thread+main thread&#x3D;11, program ends, sub thread &amp; destroyed, main thread&#x3D;1.<br><code>Mutex&lt;T&gt;</code>：one thread one time -&gt; shared data</li>
<li><code>Mutex::new(T)</code> : wrap the share data,  use <code>lock</code> to access</li>
<li><code>ler mut num::MutexGuard&lt;&#39;_,i32&gt; = counter.lock().unwrap()</code>  num is a &amp;mut</li>
<li><code>*num</code> fetch num out<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let counter::Arc&lt;Mutex&lt;i32&gt;&gt; = Arc::new(Mutex::new(0));</span><br><span class="line">    let mut handles = vec![];</span><br><span class="line"></span><br><span class="line">    for _ in 0..10 &#123;</span><br><span class="line">        let counter = Arc::clone(&amp;counter); // thread locked</span><br><span class="line">        let handle = thread::spawn(move || &#123; //</span><br><span class="line">            let mut num = counter.lock().unwrap(); // num is &amp;mut</span><br><span class="line">          </span><br><span class="line">            *num += 1;// share data +1</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for handle in handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());</span><br><span class="line">    println!(&quot;counter: &#123;&#125;&quot;,Arc::strong_count(&amp;counter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><ul>
<li>Note: one thread – multi-tasks</li>
<li><code>async fn</code> : async function，return <code>Future</code></li>
<li><code>.await</code></li>
<li><code>#[toktokio::main]</code></li>
<li><code>io::spawn(say_hello())</code>: Concurrently execute multiple async tasks.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::time::Duration;</span><br><span class="line">use tokio::time;</span><br><span class="line"></span><br><span class="line">async fn say_hello() &#123;</span><br><span class="line">    println!(&quot;Hello!&quot;);</span><br><span class="line">    time::sleep(Duration::from_secs(1)).await;</span><br><span class="line">    println!(&quot;Goodbye!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[tokio::main]</span><br><span class="line">async fn main() &#123;</span><br><span class="line">    let handle1 = tokio::spawn(say_hello());</span><br><span class="line">    let handle2 = tokio::spawn(say_hello());</span><br><span class="line"></span><br><span class="line">    handle1.await.unwrap();</span><br><span class="line">    handle2.await.unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="并发安全：所有权与借用"><a href="#并发安全：所有权与借用" class="headerlink" title="并发安全：所有权与借用"></a>并发安全：所有权与借用</h3><p>Rust 并发编程的最大优势之一是其内建的<strong>所有权系统和借用检查</strong>。Rust 通过所有权、借用和生命周期来防止数据竞争，这在其他语言中通常需要手动控制。Rust 的编译器会在<strong>编译期</strong>检查数据的访问，防止多个线程同时修改同一数据，从而保障并发安全。</p>
<ul>
<li><strong>数据竞争</strong>：当两个或多个线程同时访问<strong>共享数据</strong>并且至少有一个线程在修改数据时，数据竞争可能会发生，导致程序的不确定性。在 Rust 中，编译器会在编译时禁止数据竞争。</li>
<li><strong>所有权模型</strong>：Rust 的所有权模型确保一个线程在没有<strong>显式共享</strong>的情况下无法访问另一个线程的所有权数据，从根本上避免了并发错误。</li>
</ul>
<h2 id="show-shared-method"><a href="#show-shared-method" class="headerlink" title="show shared method"></a>show shared method</h2><ul>
<li>**<code>Arc&lt;T&gt;</code> (Atomic Reference Counting)**：<ul>
<li>multi-threaded, ensure var won’t release before all thread finish using</li>
<li>clone<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::sync::Arc;</span><br><span class="line">let data = Arc::new(42); </span><br><span class="line">let data1 = Arc::clone(&amp;data); </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>Mutex&lt;T&gt;</code> (Mutual Exclusion)**：<ul>
<li>lock: one thread read and write ths time-&gt; data</li>
<li><ul>
<li>Arc: show shared change<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line">let counter = Arc::new(Mutex::new(0)); </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>**<code>RwLock&lt;T&gt;</code> (Read-Write Lock)**：<ul>
<li>multi-read &amp; one write<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::sync::RwLock;</span><br><span class="line">let lock = RwLock::new(5);</span><br><span class="line">&#123;</span><br><span class="line">    let r = lock.read().unwrap(); </span><br><span class="line">    println!(&quot;Read: &#123;&#125;&quot;, *r);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    let mut w = lock.write().unwrap(); </span><br><span class="line">    *w += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>**<code>Rc&lt;T&gt;</code> (Reference Counting)**：<ul>
<li>single-threaded shared data<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::rc::Rc;</span><br><span class="line">let data = Rc::new(42); // 显式共享数据</span><br><span class="line">let data1 = Rc::clone(&amp;data); // 克隆 Rc 共享</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Cocurrency</tag>
        <tag>shared data</tag>
        <tag>smart point</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay5&amp;6 Ownership &amp; Referece</title>
    <url>/2024/08/26/Rust-Day5%20&amp;%20Day6/</url>
    <content><![CDATA[<h2 id="1、Transfer-of-ownership"><a href="#1、Transfer-of-ownership" class="headerlink" title="1、Transfer of ownership"></a>1、Transfer of ownership</h2><p><strong>Rust Ownership System:</strong><br>    To secure safety of memory and avoid data competition, without rely on garbage collector.</p>
<ul>
<li>Static language:<ul>
<li>Check and determine the Type of Varible While <strong>Complition</strong></li>
<li>C&#x2F;C++,rust</li>
</ul>
</li>
<li>Dynamic language:<ul>
<li>Check and determine while <strong>Runtime</strong></li>
<li>javascript, python</li>
</ul>
</li>
<li>Stack: Continuous. Static. Auto admin.  <ul>
<li>Basic data types (e.g., int, floats),</li>
<li>Elements of arrays</li>
<li>Function parameters, etc.</li>
</ul>
</li>
<li>Heap: Disperse. Dynamic. Manual admin. <ul>
<li>Through <code>Box</code>、<code>Vec</code>、<code>String</code></li>
<li><strong>rust ownership system atuo admin memory</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = 5;</span><br><span class="line">let y = x; //COPY value --double 5</span><br><span class="line"></span><br><span class="line">let s1 = &quot;上士无争&quot;.to_string();</span><br><span class="line">let s2 =s1; //Transfer ownership to a new index</span><br><span class="line">// let s3 = s1; //error. s1 doesn&#x27;t exist</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>One value – one index;</li>
<li>Second index-&gt;value  ownership transferred</li>
<li>Value out of the Block Scope will be dropped.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5; // x--stack</span><br><span class="line">    let y = Box::new(10); // y--index heap</span><br><span class="line">    let z = vec![1, 2, 3, 4, 5]; // z--dynamic array heap </span><br><span class="line">    println!(&quot;x: &#123;&#125;, y: &#123;&#125;, z: &#123;:?&#125;&quot;, x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>E.g. :  </p>
<ul>
<li><code>s2 = s1.clone()</code> √  <code>&amp;s1</code> √<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn take_ownership1(s:String)-&gt;String&#123;</span><br><span class="line">	s</span><br><span class="line">&#125;</span><br><span class="line">fn take_ownership2(s:&amp;String)-&gt;&amp;String&#123;</span><br><span class="line">	s</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">	let s1 = String::from(&quot;无善无恶心之体&quot;);</span><br><span class="line">	let s2 = take_ownership1(s1.clone());</span><br><span class="line">	let s3 = String::from(&quot;有善有恶意之动&quot;);</span><br><span class="line">	let s4 = take_ownership2(&amp;s3);</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,s2);</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、Reference"><a href="#2、Reference" class="headerlink" title="2、Reference"></a>2、Reference</h2><p>Note:</p>
<ul>
<li>Immuable Reference: Readable and immutable. One variavble – several reference</li>
<li>Mutable Reference: Readable and mutable. One variavble – one reference<ul>
<li>Immutable &amp; mutable reference can’t exist together.<br>E.g.:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mut s1 = String::from(&quot;知善知恶是良知&quot;);</span><br><span class="line">//Immutable *2</span><br><span class="line">let _s2 = &amp;s1;</span><br><span class="line">let _s3 = &amp;s1;</span><br><span class="line">println!(&quot;&#123;&#125;,&#123;&#125;&quot;,s2,s3); // s2 s3 have finishend function</span><br><span class="line"></span><br><span class="line">//Mutable reset</span><br><span class="line">let s4 = &amp;mut s1;</span><br><span class="line">*s4= String::from(&quot;为善去恶是格物&quot;);</span><br><span class="line">println!(&quot;&#123;&#125;&quot;,s4);</span><br><span class="line"></span><br><span class="line">// println!(&quot;&#123;&#125;&quot;,s2); //Error s2 s3 don&#x27;t exist this line</span><br></pre></td></tr></table></figure>
E.g.:</li>
</ul>
</li>
<li><code>for vv in v</code>: Ownership transferred to <code>vv</code></li>
<li><code>for vv in &amp;v</code>: Immutable Reference  <code>&amp;</code>–refer address <code>*</code>–read value</li>
<li><code>for vv in &amp;mut v</code>: Mutable Reference <code>*vv</code> could rewrite the value</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let v = vec![1,2,3];</span><br><span class="line">for vv in &amp;v &#123;</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,vv);</span><br><span class="line">&#125;</span><br><span class="line">println!(&quot;&#123;&#125;&quot;,v[0]);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mut _v = vec![4,5,6];</span><br><span class="line">for vv in &amp;mut _v&#123;</span><br><span class="line">	if *vv == 4&#123;</span><br><span class="line">		*vv = 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">println!(&quot;&#123;&#125;&quot;,_V[0]);</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li><strong>move</strong>: Operation upon heap stata ownership</li>
<li><strong>borrowing</strong>: Function parameters are defined varaible.</li>
<li><strong>referring</strong>: Slices<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = [1,2,3];</span><br><span class="line">let b = &amp;a[0..1];</span><br><span class="line">let c = String::from(&quot;大道无形，运行日月&quot;)；</span><br><span class="line">let d = &amp;a[..];</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、Lifetime"><a href="#3、Lifetime" class="headerlink" title="3、Lifetime"></a>3、Lifetime</h2><p>A Period during which a <strong>Reference is valid</strong> in memory<br><code>let s</code>: start point–Defined  end point–<strong>Block Scope ending</strong><br><code>let ss = &amp;s</code>: start point–Referred  end point– <strong>shorter than s</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = 5; // `x` starts</span><br><span class="line">let r = &amp;x; // `r` starts</span><br><span class="line">println!(&quot;&#123;&#125;&quot;, r); </span><br><span class="line">let y = x + 1;</span><br><span class="line">println!(&quot;&#123;&#125;&quot;,y);</span><br><span class="line">//r ends. shorter than x, or is invalid;  x ends</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>E.g.:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn longeststr&lt;&#x27;a&gt;(a:&amp; &#x27;a String, b:&amp; &#x27;a String)-&gt;&amp; &#x27;a String&#123;</span><br><span class="line">	if a.len()&gt;b.len()&#123;</span><br><span class="line">		a</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">	let x = &quot;大道无形，生育天地&quot;.to_string();</span><br><span class="line">	let y = &quot;大道无情&quot;.to_string();</span><br><span class="line">	let a = longeststr(&amp;x,&amp;y);</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,a);</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li><code>&lt;&#39;a&gt;</code> : Lifecycle annotation<ul>
<li><code>input:a b output str slices --&gt; valid in a same lifetime</code></li>
<li>Therefore, the compiler could indentify the validation of <strong>function parameter referred</strong> in <code>main()</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>ownership</tag>
        <tag>reference</tag>
      </tags>
  </entry>
  <entry>
    <title>RustDay7&amp;8&amp;9 Rust data type—Basic&amp;Array+Slices&amp;String</title>
    <url>/2024/08/26/Rust-Day7%20&amp;%20Day8%20&amp;%20Day9/</url>
    <content><![CDATA[<h2 id="1、Basic-Type"><a href="#1、Basic-Type" class="headerlink" title="1、Basic Type"></a>1、Basic Type</h2><ul>
<li><code>i8 i16 i32 i64 i128</code>; <code>u8 u16 u32 u64 u128</code><br>(2): <code>0b111_000</code> (10): <code>1132_235</code>  (8): <code>0o77</code>  (16): <code>0xff</code> </li>
<li><code>f32</code> <code>f64</code> (accuracy)<br>Note: <code>NAN</code> Result undefined in math<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let v = (-2.3_f64).sqrt();</span><br><span class="line">if v.is_nan()&#123;</span><br><span class="line">	println!(&quot;v is nan&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Bool</li>
<li>Char: Unicode 4bit</li>
<li>Sequence <code>(1..4):1 2 3</code> <code>(a..=z)</code><br>Note: Type transformation<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let i:i32 = 5;</span><br><span class="line">let k:f32 = i as f32; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、Array-and-Slices"><a href="#2、Array-and-Slices" class="headerlink" title="2、Array and Slices"></a>2、Array and Slices</h2><p>Array :</p>
<ul>
<li>same type data series</li>
<li>Static</li>
<li>elements num unchanged<br>Slice:</li>
<li>Array String Vec</li>
<li>type: <code>&amp;[i32]</code> Restoring the index of the first element and the length.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn reset(a: &amp;[i32]) -&gt; Vec&lt;i32&gt;&#123; </span><br><span class="line">//input: Slice  output:Vec dynamic array</span><br><span class="line"></span><br><span class="line">	a.iter().map(|&amp;x| x*3).collect() //return </span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">	let b = [1,2,3,4];</span><br><span class="line">	println!(&quot;&#123;:?&#125;&quot;,reset(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Common functions</li>
<li>Iteration and Reset<br><code>iter_mut()</code> Mutable<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let r: &amp;mut [i32;4] = &amp;mut [1,2,3,4];</span><br><span class="line">for i:&amp;mut i32 in r.iter_mut()&#123;</span><br><span class="line">	*i *= 2;</span><br><span class="line">&#125;</span><br><span class="line">println!(&quot;&#123;:?&#125;&quot;,r);</span><br></pre></td></tr></table></figure>
<code>s.len()</code>   <code>s.is_empty()</code><br><code>s.windows(size:3)</code>  <code>s.starts_with(&amp;[10])</code>  <code>s.clone()</code></li>
</ul>
<h2 id="3、String-and-str"><a href="#3、String-and-str" class="headerlink" title="3、String and &amp;str"></a>3、String and &amp;str</h2><ul>
<li>Define:<br><code>&amp;str</code> : Index, Unchangeable, restored in Stack, Static, No ownership<br><code>String::from(&quot;&quot;)</code> : Changeable, heap, dynamic, ownership<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x: [&amp;str;3] = [&quot;名&quot;, &quot;可&quot;, &quot;名&quot;];</span><br><span class="line">    let mut y: [String;3] = [String::from(&quot;非&quot;),String::from(&quot;常&quot;),String::from(&quot;道&quot;)];</span><br><span class="line">    y[2] = String::from(&quot;名&quot;);</span><br><span class="line">    println!(&quot;&#123;:?&#125;,&#123;:?&#125;&quot;,x.join(&quot;&quot;),y.join(&quot;&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Transformation<br><code>&amp;str</code> -&gt; <code>String</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let s = &quot;hello&quot;;</span><br><span class="line">let string1 = s.to_string();</span><br><span class="line">// or</span><br><span class="line">let string2 = String::from(s);</span><br></pre></td></tr></table></figure>
<code>String</code> -&gt; <code>&amp;str</code><br><code>s.as_str()</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let sting = String::from(&quot;无名,天地之始&quot;);</span><br><span class="line">let s1 = &amp;s[0..6] //&quot;无名&quot; one character -- 3bits</span><br><span class="line">let s2 = string.as_str();</span><br></pre></td></tr></table></figure>
<code>i32</code> -&gt;<code>String</code><br><code>String::from_utf8(v).unwrap()</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">	let v = vec![104,101,108,111];</span><br><span class="line">	let s = String::from_utf8(v).unwrap();</span><br><span class="line">	println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Common function about String<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string.push_str() //add</span><br><span class="line">string.insert(5,&quot; &quot;)</span><br><span class="line">string.replace(&quot;&quot;,&quot;&quot;,2)//generate new string</span><br><span class="line">string.replace_range(6..10,&quot;RUST&quot;)</span><br><span class="line">string.pop()//delete last bit</span><br><span class="line">string.remove(0)</span><br><span class="line">string1 + &quot;,&quot; + string2.as_str --&gt;String</span><br><span class="line">s = format!(&quot;&#123;&#125;&#123;&#125;&quot;,string1,string2);</span><br></pre></td></tr></table></figure>
Note: As <strong>function parameter</strong>, it’s better to use <strong>&amp;str</strong></li>
<li>The original variable can’t be used after function calling<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn add(s:String)-&gt;String&#123;</span><br><span class="line">	s + &quot;!&quot;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">	let s = String::from(&quot;hello&quot;);</span><br><span class="line">	add(s);</span><br><span class="line">	//println!(&quot;&#123;&#125;&quot;,s); // invalid!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>fn fun(s: &amp;str)</code> could accept <code>&amp;String</code> <code>&amp; &#39;satic str</code></li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>data type</tag>
      </tags>
  </entry>
</search>
